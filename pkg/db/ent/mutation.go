// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/couponwithdraw"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/goodledger"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/goodstatement"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/ledger"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/ledgerlock"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/profit"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/simulateledger"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/simulateprofit"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/simulatestatement"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/statement"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/unsoldstatement"
	"github.com/NpoolPlatform/ledger-middleware/pkg/db/ent/withdraw"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCouponWithdraw    = "CouponWithdraw"
	TypeGoodLedger        = "GoodLedger"
	TypeGoodStatement     = "GoodStatement"
	TypeLedger            = "Ledger"
	TypeLedgerLock        = "LedgerLock"
	TypeProfit            = "Profit"
	TypeSimulateLedger    = "SimulateLedger"
	TypeSimulateProfit    = "SimulateProfit"
	TypeSimulateStatement = "SimulateStatement"
	TypeStatement         = "Statement"
	TypeUnsoldStatement   = "UnsoldStatement"
	TypeWithdraw          = "Withdraw"
)

// CouponWithdrawMutation represents an operation that mutates the CouponWithdraw nodes in the graph.
type CouponWithdrawMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	allocated_id  *uuid.UUID
	state         *string
	amount        *decimal.Decimal
	addamount     *decimal.Decimal
	review_id     *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponWithdraw, error)
	predicates    []predicate.CouponWithdraw
}

var _ ent.Mutation = (*CouponWithdrawMutation)(nil)

// couponwithdrawOption allows management of the mutation configuration using functional options.
type couponwithdrawOption func(*CouponWithdrawMutation)

// newCouponWithdrawMutation creates new mutation for the CouponWithdraw entity.
func newCouponWithdrawMutation(c config, op Op, opts ...couponwithdrawOption) *CouponWithdrawMutation {
	m := &CouponWithdrawMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponWithdraw,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponWithdrawID sets the ID field of the mutation.
func withCouponWithdrawID(id uint32) couponwithdrawOption {
	return func(m *CouponWithdrawMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponWithdraw
		)
		m.oldValue = func(ctx context.Context) (*CouponWithdraw, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponWithdraw.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponWithdraw sets the old CouponWithdraw of the mutation.
func withCouponWithdraw(node *CouponWithdraw) couponwithdrawOption {
	return func(m *CouponWithdrawMutation) {
		m.oldValue = func(context.Context) (*CouponWithdraw, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponWithdrawMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponWithdrawMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponWithdraw entities.
func (m *CouponWithdrawMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponWithdrawMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponWithdrawMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponWithdraw.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponWithdrawMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponWithdrawMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponWithdrawMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponWithdrawMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponWithdrawMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponWithdrawMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponWithdrawMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponWithdrawMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponWithdrawMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponWithdrawMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponWithdrawMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponWithdrawMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponWithdrawMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponWithdrawMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponWithdrawMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CouponWithdrawMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CouponWithdrawMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CouponWithdrawMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponWithdrawMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponWithdrawMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CouponWithdrawMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[couponwithdraw.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CouponWithdrawMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponWithdrawMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, couponwithdraw.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CouponWithdrawMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponWithdrawMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CouponWithdrawMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[couponwithdraw.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CouponWithdrawMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponWithdrawMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, couponwithdraw.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *CouponWithdrawMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *CouponWithdrawMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *CouponWithdrawMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[couponwithdraw.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *CouponWithdrawMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *CouponWithdrawMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, couponwithdraw.FieldCoinTypeID)
}

// SetAllocatedID sets the "allocated_id" field.
func (m *CouponWithdrawMutation) SetAllocatedID(u uuid.UUID) {
	m.allocated_id = &u
}

// AllocatedID returns the value of the "allocated_id" field in the mutation.
func (m *CouponWithdrawMutation) AllocatedID() (r uuid.UUID, exists bool) {
	v := m.allocated_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocatedID returns the old "allocated_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldAllocatedID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocatedID: %w", err)
	}
	return oldValue.AllocatedID, nil
}

// ClearAllocatedID clears the value of the "allocated_id" field.
func (m *CouponWithdrawMutation) ClearAllocatedID() {
	m.allocated_id = nil
	m.clearedFields[couponwithdraw.FieldAllocatedID] = struct{}{}
}

// AllocatedIDCleared returns if the "allocated_id" field was cleared in this mutation.
func (m *CouponWithdrawMutation) AllocatedIDCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldAllocatedID]
	return ok
}

// ResetAllocatedID resets all changes to the "allocated_id" field.
func (m *CouponWithdrawMutation) ResetAllocatedID() {
	m.allocated_id = nil
	delete(m.clearedFields, couponwithdraw.FieldAllocatedID)
}

// SetState sets the "state" field.
func (m *CouponWithdrawMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *CouponWithdrawMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *CouponWithdrawMutation) ClearState() {
	m.state = nil
	m.clearedFields[couponwithdraw.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *CouponWithdrawMutation) StateCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *CouponWithdrawMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, couponwithdraw.FieldState)
}

// SetAmount sets the "amount" field.
func (m *CouponWithdrawMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CouponWithdrawMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *CouponWithdrawMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CouponWithdrawMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *CouponWithdrawMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[couponwithdraw.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *CouponWithdrawMutation) AmountCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *CouponWithdrawMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, couponwithdraw.FieldAmount)
}

// SetReviewID sets the "review_id" field.
func (m *CouponWithdrawMutation) SetReviewID(u uuid.UUID) {
	m.review_id = &u
}

// ReviewID returns the value of the "review_id" field in the mutation.
func (m *CouponWithdrawMutation) ReviewID() (r uuid.UUID, exists bool) {
	v := m.review_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewID returns the old "review_id" field's value of the CouponWithdraw entity.
// If the CouponWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponWithdrawMutation) OldReviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewID: %w", err)
	}
	return oldValue.ReviewID, nil
}

// ClearReviewID clears the value of the "review_id" field.
func (m *CouponWithdrawMutation) ClearReviewID() {
	m.review_id = nil
	m.clearedFields[couponwithdraw.FieldReviewID] = struct{}{}
}

// ReviewIDCleared returns if the "review_id" field was cleared in this mutation.
func (m *CouponWithdrawMutation) ReviewIDCleared() bool {
	_, ok := m.clearedFields[couponwithdraw.FieldReviewID]
	return ok
}

// ResetReviewID resets all changes to the "review_id" field.
func (m *CouponWithdrawMutation) ResetReviewID() {
	m.review_id = nil
	delete(m.clearedFields, couponwithdraw.FieldReviewID)
}

// Where appends a list predicates to the CouponWithdrawMutation builder.
func (m *CouponWithdrawMutation) Where(ps ...predicate.CouponWithdraw) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponWithdrawMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponWithdraw).
func (m *CouponWithdrawMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponWithdrawMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, couponwithdraw.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponwithdraw.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponwithdraw.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, couponwithdraw.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, couponwithdraw.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, couponwithdraw.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, couponwithdraw.FieldCoinTypeID)
	}
	if m.allocated_id != nil {
		fields = append(fields, couponwithdraw.FieldAllocatedID)
	}
	if m.state != nil {
		fields = append(fields, couponwithdraw.FieldState)
	}
	if m.amount != nil {
		fields = append(fields, couponwithdraw.FieldAmount)
	}
	if m.review_id != nil {
		fields = append(fields, couponwithdraw.FieldReviewID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponWithdrawMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		return m.CreatedAt()
	case couponwithdraw.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponwithdraw.FieldDeletedAt:
		return m.DeletedAt()
	case couponwithdraw.FieldEntID:
		return m.EntID()
	case couponwithdraw.FieldAppID:
		return m.AppID()
	case couponwithdraw.FieldUserID:
		return m.UserID()
	case couponwithdraw.FieldCoinTypeID:
		return m.CoinTypeID()
	case couponwithdraw.FieldAllocatedID:
		return m.AllocatedID()
	case couponwithdraw.FieldState:
		return m.State()
	case couponwithdraw.FieldAmount:
		return m.Amount()
	case couponwithdraw.FieldReviewID:
		return m.ReviewID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponWithdrawMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponwithdraw.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponwithdraw.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponwithdraw.FieldEntID:
		return m.OldEntID(ctx)
	case couponwithdraw.FieldAppID:
		return m.OldAppID(ctx)
	case couponwithdraw.FieldUserID:
		return m.OldUserID(ctx)
	case couponwithdraw.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case couponwithdraw.FieldAllocatedID:
		return m.OldAllocatedID(ctx)
	case couponwithdraw.FieldState:
		return m.OldState(ctx)
	case couponwithdraw.FieldAmount:
		return m.OldAmount(ctx)
	case couponwithdraw.FieldReviewID:
		return m.OldReviewID(ctx)
	}
	return nil, fmt.Errorf("unknown CouponWithdraw field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponWithdrawMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponwithdraw.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponwithdraw.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponwithdraw.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case couponwithdraw.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponwithdraw.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponwithdraw.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case couponwithdraw.FieldAllocatedID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocatedID(v)
		return nil
	case couponwithdraw.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case couponwithdraw.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case couponwithdraw.FieldReviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewID(v)
		return nil
	}
	return fmt.Errorf("unknown CouponWithdraw field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponWithdrawMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponwithdraw.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponwithdraw.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponwithdraw.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, couponwithdraw.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponWithdrawMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponwithdraw.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponwithdraw.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponwithdraw.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponWithdrawMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponwithdraw.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponwithdraw.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponwithdraw.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CouponWithdraw numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponWithdrawMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponwithdraw.FieldAppID) {
		fields = append(fields, couponwithdraw.FieldAppID)
	}
	if m.FieldCleared(couponwithdraw.FieldUserID) {
		fields = append(fields, couponwithdraw.FieldUserID)
	}
	if m.FieldCleared(couponwithdraw.FieldCoinTypeID) {
		fields = append(fields, couponwithdraw.FieldCoinTypeID)
	}
	if m.FieldCleared(couponwithdraw.FieldAllocatedID) {
		fields = append(fields, couponwithdraw.FieldAllocatedID)
	}
	if m.FieldCleared(couponwithdraw.FieldState) {
		fields = append(fields, couponwithdraw.FieldState)
	}
	if m.FieldCleared(couponwithdraw.FieldAmount) {
		fields = append(fields, couponwithdraw.FieldAmount)
	}
	if m.FieldCleared(couponwithdraw.FieldReviewID) {
		fields = append(fields, couponwithdraw.FieldReviewID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponWithdrawMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponWithdrawMutation) ClearField(name string) error {
	switch name {
	case couponwithdraw.FieldAppID:
		m.ClearAppID()
		return nil
	case couponwithdraw.FieldUserID:
		m.ClearUserID()
		return nil
	case couponwithdraw.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case couponwithdraw.FieldAllocatedID:
		m.ClearAllocatedID()
		return nil
	case couponwithdraw.FieldState:
		m.ClearState()
		return nil
	case couponwithdraw.FieldAmount:
		m.ClearAmount()
		return nil
	case couponwithdraw.FieldReviewID:
		m.ClearReviewID()
		return nil
	}
	return fmt.Errorf("unknown CouponWithdraw nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponWithdrawMutation) ResetField(name string) error {
	switch name {
	case couponwithdraw.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponwithdraw.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponwithdraw.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponwithdraw.FieldEntID:
		m.ResetEntID()
		return nil
	case couponwithdraw.FieldAppID:
		m.ResetAppID()
		return nil
	case couponwithdraw.FieldUserID:
		m.ResetUserID()
		return nil
	case couponwithdraw.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case couponwithdraw.FieldAllocatedID:
		m.ResetAllocatedID()
		return nil
	case couponwithdraw.FieldState:
		m.ResetState()
		return nil
	case couponwithdraw.FieldAmount:
		m.ResetAmount()
		return nil
	case couponwithdraw.FieldReviewID:
		m.ResetReviewID()
		return nil
	}
	return fmt.Errorf("unknown CouponWithdraw field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponWithdrawMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponWithdrawMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponWithdrawMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponWithdrawMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponWithdrawMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponWithdrawMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponWithdrawMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponWithdraw unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponWithdrawMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponWithdraw edge %s", name)
}

// GoodLedgerMutation represents an operation that mutates the GoodLedger nodes in the graph.
type GoodLedgerMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	ent_id         *uuid.UUID
	good_id        *uuid.UUID
	coin_type_id   *uuid.UUID
	amount         *decimal.Decimal
	addamount      *decimal.Decimal
	to_platform    *decimal.Decimal
	addto_platform *decimal.Decimal
	to_user        *decimal.Decimal
	addto_user     *decimal.Decimal
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GoodLedger, error)
	predicates     []predicate.GoodLedger
}

var _ ent.Mutation = (*GoodLedgerMutation)(nil)

// goodledgerOption allows management of the mutation configuration using functional options.
type goodledgerOption func(*GoodLedgerMutation)

// newGoodLedgerMutation creates new mutation for the GoodLedger entity.
func newGoodLedgerMutation(c config, op Op, opts ...goodledgerOption) *GoodLedgerMutation {
	m := &GoodLedgerMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodLedger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodLedgerID sets the ID field of the mutation.
func withGoodLedgerID(id uint32) goodledgerOption {
	return func(m *GoodLedgerMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodLedger
		)
		m.oldValue = func(ctx context.Context) (*GoodLedger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodLedger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodLedger sets the old GoodLedger of the mutation.
func withGoodLedger(node *GoodLedger) goodledgerOption {
	return func(m *GoodLedgerMutation) {
		m.oldValue = func(context.Context) (*GoodLedger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodLedgerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodLedgerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodLedger entities.
func (m *GoodLedgerMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodLedgerMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodLedgerMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodLedger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodLedgerMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodLedgerMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodLedgerMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodLedgerMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodLedgerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodLedgerMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodLedgerMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodLedgerMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodLedgerMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodLedgerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodLedgerMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodLedgerMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodLedgerMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodLedgerMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodLedgerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *GoodLedgerMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodLedgerMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodLedgerMutation) ResetEntID() {
	m.ent_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodLedgerMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodLedgerMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodLedgerMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodledger.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodLedgerMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodledger.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodLedgerMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodledger.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodLedgerMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodLedgerMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *GoodLedgerMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[goodledger.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *GoodLedgerMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodledger.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodLedgerMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, goodledger.FieldCoinTypeID)
}

// SetAmount sets the "amount" field.
func (m *GoodLedgerMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GoodLedgerMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *GoodLedgerMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GoodLedgerMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *GoodLedgerMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[goodledger.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *GoodLedgerMutation) AmountCleared() bool {
	_, ok := m.clearedFields[goodledger.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *GoodLedgerMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, goodledger.FieldAmount)
}

// SetToPlatform sets the "to_platform" field.
func (m *GoodLedgerMutation) SetToPlatform(d decimal.Decimal) {
	m.to_platform = &d
	m.addto_platform = nil
}

// ToPlatform returns the value of the "to_platform" field in the mutation.
func (m *GoodLedgerMutation) ToPlatform() (r decimal.Decimal, exists bool) {
	v := m.to_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldToPlatform returns the old "to_platform" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldToPlatform(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToPlatform: %w", err)
	}
	return oldValue.ToPlatform, nil
}

// AddToPlatform adds d to the "to_platform" field.
func (m *GoodLedgerMutation) AddToPlatform(d decimal.Decimal) {
	if m.addto_platform != nil {
		*m.addto_platform = m.addto_platform.Add(d)
	} else {
		m.addto_platform = &d
	}
}

// AddedToPlatform returns the value that was added to the "to_platform" field in this mutation.
func (m *GoodLedgerMutation) AddedToPlatform() (r decimal.Decimal, exists bool) {
	v := m.addto_platform
	if v == nil {
		return
	}
	return *v, true
}

// ClearToPlatform clears the value of the "to_platform" field.
func (m *GoodLedgerMutation) ClearToPlatform() {
	m.to_platform = nil
	m.addto_platform = nil
	m.clearedFields[goodledger.FieldToPlatform] = struct{}{}
}

// ToPlatformCleared returns if the "to_platform" field was cleared in this mutation.
func (m *GoodLedgerMutation) ToPlatformCleared() bool {
	_, ok := m.clearedFields[goodledger.FieldToPlatform]
	return ok
}

// ResetToPlatform resets all changes to the "to_platform" field.
func (m *GoodLedgerMutation) ResetToPlatform() {
	m.to_platform = nil
	m.addto_platform = nil
	delete(m.clearedFields, goodledger.FieldToPlatform)
}

// SetToUser sets the "to_user" field.
func (m *GoodLedgerMutation) SetToUser(d decimal.Decimal) {
	m.to_user = &d
	m.addto_user = nil
}

// ToUser returns the value of the "to_user" field in the mutation.
func (m *GoodLedgerMutation) ToUser() (r decimal.Decimal, exists bool) {
	v := m.to_user
	if v == nil {
		return
	}
	return *v, true
}

// OldToUser returns the old "to_user" field's value of the GoodLedger entity.
// If the GoodLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodLedgerMutation) OldToUser(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUser: %w", err)
	}
	return oldValue.ToUser, nil
}

// AddToUser adds d to the "to_user" field.
func (m *GoodLedgerMutation) AddToUser(d decimal.Decimal) {
	if m.addto_user != nil {
		*m.addto_user = m.addto_user.Add(d)
	} else {
		m.addto_user = &d
	}
}

// AddedToUser returns the value that was added to the "to_user" field in this mutation.
func (m *GoodLedgerMutation) AddedToUser() (r decimal.Decimal, exists bool) {
	v := m.addto_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearToUser clears the value of the "to_user" field.
func (m *GoodLedgerMutation) ClearToUser() {
	m.to_user = nil
	m.addto_user = nil
	m.clearedFields[goodledger.FieldToUser] = struct{}{}
}

// ToUserCleared returns if the "to_user" field was cleared in this mutation.
func (m *GoodLedgerMutation) ToUserCleared() bool {
	_, ok := m.clearedFields[goodledger.FieldToUser]
	return ok
}

// ResetToUser resets all changes to the "to_user" field.
func (m *GoodLedgerMutation) ResetToUser() {
	m.to_user = nil
	m.addto_user = nil
	delete(m.clearedFields, goodledger.FieldToUser)
}

// Where appends a list predicates to the GoodLedgerMutation builder.
func (m *GoodLedgerMutation) Where(ps ...predicate.GoodLedger) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodLedgerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodLedger).
func (m *GoodLedgerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodLedgerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodledger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodledger.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodledger.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, goodledger.FieldEntID)
	}
	if m.good_id != nil {
		fields = append(fields, goodledger.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, goodledger.FieldCoinTypeID)
	}
	if m.amount != nil {
		fields = append(fields, goodledger.FieldAmount)
	}
	if m.to_platform != nil {
		fields = append(fields, goodledger.FieldToPlatform)
	}
	if m.to_user != nil {
		fields = append(fields, goodledger.FieldToUser)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodLedgerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodledger.FieldCreatedAt:
		return m.CreatedAt()
	case goodledger.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodledger.FieldDeletedAt:
		return m.DeletedAt()
	case goodledger.FieldEntID:
		return m.EntID()
	case goodledger.FieldGoodID:
		return m.GoodID()
	case goodledger.FieldCoinTypeID:
		return m.CoinTypeID()
	case goodledger.FieldAmount:
		return m.Amount()
	case goodledger.FieldToPlatform:
		return m.ToPlatform()
	case goodledger.FieldToUser:
		return m.ToUser()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodLedgerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodledger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodledger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodledger.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodledger.FieldEntID:
		return m.OldEntID(ctx)
	case goodledger.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodledger.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case goodledger.FieldAmount:
		return m.OldAmount(ctx)
	case goodledger.FieldToPlatform:
		return m.OldToPlatform(ctx)
	case goodledger.FieldToUser:
		return m.OldToUser(ctx)
	}
	return nil, fmt.Errorf("unknown GoodLedger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodLedgerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodledger.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodledger.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodledger.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodledger.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodledger.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodledger.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case goodledger.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case goodledger.FieldToPlatform:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToPlatform(v)
		return nil
	case goodledger.FieldToUser:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUser(v)
		return nil
	}
	return fmt.Errorf("unknown GoodLedger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodLedgerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodledger.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodledger.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodledger.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, goodledger.FieldAmount)
	}
	if m.addto_platform != nil {
		fields = append(fields, goodledger.FieldToPlatform)
	}
	if m.addto_user != nil {
		fields = append(fields, goodledger.FieldToUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodLedgerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodledger.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodledger.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodledger.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodledger.FieldAmount:
		return m.AddedAmount()
	case goodledger.FieldToPlatform:
		return m.AddedToPlatform()
	case goodledger.FieldToUser:
		return m.AddedToUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodLedgerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodledger.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodledger.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodledger.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodledger.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case goodledger.FieldToPlatform:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToPlatform(v)
		return nil
	case goodledger.FieldToUser:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToUser(v)
		return nil
	}
	return fmt.Errorf("unknown GoodLedger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodLedgerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodledger.FieldGoodID) {
		fields = append(fields, goodledger.FieldGoodID)
	}
	if m.FieldCleared(goodledger.FieldCoinTypeID) {
		fields = append(fields, goodledger.FieldCoinTypeID)
	}
	if m.FieldCleared(goodledger.FieldAmount) {
		fields = append(fields, goodledger.FieldAmount)
	}
	if m.FieldCleared(goodledger.FieldToPlatform) {
		fields = append(fields, goodledger.FieldToPlatform)
	}
	if m.FieldCleared(goodledger.FieldToUser) {
		fields = append(fields, goodledger.FieldToUser)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodLedgerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodLedgerMutation) ClearField(name string) error {
	switch name {
	case goodledger.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodledger.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case goodledger.FieldAmount:
		m.ClearAmount()
		return nil
	case goodledger.FieldToPlatform:
		m.ClearToPlatform()
		return nil
	case goodledger.FieldToUser:
		m.ClearToUser()
		return nil
	}
	return fmt.Errorf("unknown GoodLedger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodLedgerMutation) ResetField(name string) error {
	switch name {
	case goodledger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodledger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodledger.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodledger.FieldEntID:
		m.ResetEntID()
		return nil
	case goodledger.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodledger.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case goodledger.FieldAmount:
		m.ResetAmount()
		return nil
	case goodledger.FieldToPlatform:
		m.ResetToPlatform()
		return nil
	case goodledger.FieldToUser:
		m.ResetToUser()
		return nil
	}
	return fmt.Errorf("unknown GoodLedger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodLedgerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodLedgerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodLedgerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodLedgerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodLedgerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodLedgerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodLedgerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodLedger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodLedgerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodLedger edge %s", name)
}

// GoodStatementMutation represents an operation that mutates the GoodStatement nodes in the graph.
type GoodStatementMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uint32
	created_at                      *uint32
	addcreated_at                   *int32
	updated_at                      *uint32
	addupdated_at                   *int32
	deleted_at                      *uint32
	adddeleted_at                   *int32
	ent_id                          *uuid.UUID
	good_id                         *uuid.UUID
	coin_type_id                    *uuid.UUID
	amount                          *decimal.Decimal
	addamount                       *decimal.Decimal
	to_platform                     *decimal.Decimal
	addto_platform                  *decimal.Decimal
	to_user                         *decimal.Decimal
	addto_user                      *decimal.Decimal
	technique_service_fee_amount    *decimal.Decimal
	addtechnique_service_fee_amount *decimal.Decimal
	benefit_date                    *uint32
	addbenefit_date                 *int32
	clearedFields                   map[string]struct{}
	done                            bool
	oldValue                        func(context.Context) (*GoodStatement, error)
	predicates                      []predicate.GoodStatement
}

var _ ent.Mutation = (*GoodStatementMutation)(nil)

// goodstatementOption allows management of the mutation configuration using functional options.
type goodstatementOption func(*GoodStatementMutation)

// newGoodStatementMutation creates new mutation for the GoodStatement entity.
func newGoodStatementMutation(c config, op Op, opts ...goodstatementOption) *GoodStatementMutation {
	m := &GoodStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodStatementID sets the ID field of the mutation.
func withGoodStatementID(id uint32) goodstatementOption {
	return func(m *GoodStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodStatement
		)
		m.oldValue = func(ctx context.Context) (*GoodStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodStatement sets the old GoodStatement of the mutation.
func withGoodStatement(node *GoodStatement) goodstatementOption {
	return func(m *GoodStatementMutation) {
		m.oldValue = func(context.Context) (*GoodStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodStatement entities.
func (m *GoodStatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodStatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodStatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodStatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodStatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodStatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodStatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodStatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodStatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodStatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodStatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodStatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodStatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodStatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodStatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodStatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *GoodStatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodStatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodStatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodStatementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodStatementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodStatementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodstatement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodStatementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodStatementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodstatement.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodStatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodStatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *GoodStatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[goodstatement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *GoodStatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodStatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, goodstatement.FieldCoinTypeID)
}

// SetAmount sets the "amount" field.
func (m *GoodStatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GoodStatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *GoodStatementMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GoodStatementMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *GoodStatementMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[goodstatement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *GoodStatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *GoodStatementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, goodstatement.FieldAmount)
}

// SetToPlatform sets the "to_platform" field.
func (m *GoodStatementMutation) SetToPlatform(d decimal.Decimal) {
	m.to_platform = &d
	m.addto_platform = nil
}

// ToPlatform returns the value of the "to_platform" field in the mutation.
func (m *GoodStatementMutation) ToPlatform() (r decimal.Decimal, exists bool) {
	v := m.to_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldToPlatform returns the old "to_platform" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldToPlatform(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToPlatform: %w", err)
	}
	return oldValue.ToPlatform, nil
}

// AddToPlatform adds d to the "to_platform" field.
func (m *GoodStatementMutation) AddToPlatform(d decimal.Decimal) {
	if m.addto_platform != nil {
		*m.addto_platform = m.addto_platform.Add(d)
	} else {
		m.addto_platform = &d
	}
}

// AddedToPlatform returns the value that was added to the "to_platform" field in this mutation.
func (m *GoodStatementMutation) AddedToPlatform() (r decimal.Decimal, exists bool) {
	v := m.addto_platform
	if v == nil {
		return
	}
	return *v, true
}

// ClearToPlatform clears the value of the "to_platform" field.
func (m *GoodStatementMutation) ClearToPlatform() {
	m.to_platform = nil
	m.addto_platform = nil
	m.clearedFields[goodstatement.FieldToPlatform] = struct{}{}
}

// ToPlatformCleared returns if the "to_platform" field was cleared in this mutation.
func (m *GoodStatementMutation) ToPlatformCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldToPlatform]
	return ok
}

// ResetToPlatform resets all changes to the "to_platform" field.
func (m *GoodStatementMutation) ResetToPlatform() {
	m.to_platform = nil
	m.addto_platform = nil
	delete(m.clearedFields, goodstatement.FieldToPlatform)
}

// SetToUser sets the "to_user" field.
func (m *GoodStatementMutation) SetToUser(d decimal.Decimal) {
	m.to_user = &d
	m.addto_user = nil
}

// ToUser returns the value of the "to_user" field in the mutation.
func (m *GoodStatementMutation) ToUser() (r decimal.Decimal, exists bool) {
	v := m.to_user
	if v == nil {
		return
	}
	return *v, true
}

// OldToUser returns the old "to_user" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldToUser(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUser: %w", err)
	}
	return oldValue.ToUser, nil
}

// AddToUser adds d to the "to_user" field.
func (m *GoodStatementMutation) AddToUser(d decimal.Decimal) {
	if m.addto_user != nil {
		*m.addto_user = m.addto_user.Add(d)
	} else {
		m.addto_user = &d
	}
}

// AddedToUser returns the value that was added to the "to_user" field in this mutation.
func (m *GoodStatementMutation) AddedToUser() (r decimal.Decimal, exists bool) {
	v := m.addto_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearToUser clears the value of the "to_user" field.
func (m *GoodStatementMutation) ClearToUser() {
	m.to_user = nil
	m.addto_user = nil
	m.clearedFields[goodstatement.FieldToUser] = struct{}{}
}

// ToUserCleared returns if the "to_user" field was cleared in this mutation.
func (m *GoodStatementMutation) ToUserCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldToUser]
	return ok
}

// ResetToUser resets all changes to the "to_user" field.
func (m *GoodStatementMutation) ResetToUser() {
	m.to_user = nil
	m.addto_user = nil
	delete(m.clearedFields, goodstatement.FieldToUser)
}

// SetTechniqueServiceFeeAmount sets the "technique_service_fee_amount" field.
func (m *GoodStatementMutation) SetTechniqueServiceFeeAmount(d decimal.Decimal) {
	m.technique_service_fee_amount = &d
	m.addtechnique_service_fee_amount = nil
}

// TechniqueServiceFeeAmount returns the value of the "technique_service_fee_amount" field in the mutation.
func (m *GoodStatementMutation) TechniqueServiceFeeAmount() (r decimal.Decimal, exists bool) {
	v := m.technique_service_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTechniqueServiceFeeAmount returns the old "technique_service_fee_amount" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldTechniqueServiceFeeAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechniqueServiceFeeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechniqueServiceFeeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechniqueServiceFeeAmount: %w", err)
	}
	return oldValue.TechniqueServiceFeeAmount, nil
}

// AddTechniqueServiceFeeAmount adds d to the "technique_service_fee_amount" field.
func (m *GoodStatementMutation) AddTechniqueServiceFeeAmount(d decimal.Decimal) {
	if m.addtechnique_service_fee_amount != nil {
		*m.addtechnique_service_fee_amount = m.addtechnique_service_fee_amount.Add(d)
	} else {
		m.addtechnique_service_fee_amount = &d
	}
}

// AddedTechniqueServiceFeeAmount returns the value that was added to the "technique_service_fee_amount" field in this mutation.
func (m *GoodStatementMutation) AddedTechniqueServiceFeeAmount() (r decimal.Decimal, exists bool) {
	v := m.addtechnique_service_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTechniqueServiceFeeAmount clears the value of the "technique_service_fee_amount" field.
func (m *GoodStatementMutation) ClearTechniqueServiceFeeAmount() {
	m.technique_service_fee_amount = nil
	m.addtechnique_service_fee_amount = nil
	m.clearedFields[goodstatement.FieldTechniqueServiceFeeAmount] = struct{}{}
}

// TechniqueServiceFeeAmountCleared returns if the "technique_service_fee_amount" field was cleared in this mutation.
func (m *GoodStatementMutation) TechniqueServiceFeeAmountCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldTechniqueServiceFeeAmount]
	return ok
}

// ResetTechniqueServiceFeeAmount resets all changes to the "technique_service_fee_amount" field.
func (m *GoodStatementMutation) ResetTechniqueServiceFeeAmount() {
	m.technique_service_fee_amount = nil
	m.addtechnique_service_fee_amount = nil
	delete(m.clearedFields, goodstatement.FieldTechniqueServiceFeeAmount)
}

// SetBenefitDate sets the "benefit_date" field.
func (m *GoodStatementMutation) SetBenefitDate(u uint32) {
	m.benefit_date = &u
	m.addbenefit_date = nil
}

// BenefitDate returns the value of the "benefit_date" field in the mutation.
func (m *GoodStatementMutation) BenefitDate() (r uint32, exists bool) {
	v := m.benefit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitDate returns the old "benefit_date" field's value of the GoodStatement entity.
// If the GoodStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodStatementMutation) OldBenefitDate(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitDate: %w", err)
	}
	return oldValue.BenefitDate, nil
}

// AddBenefitDate adds u to the "benefit_date" field.
func (m *GoodStatementMutation) AddBenefitDate(u int32) {
	if m.addbenefit_date != nil {
		*m.addbenefit_date += u
	} else {
		m.addbenefit_date = &u
	}
}

// AddedBenefitDate returns the value that was added to the "benefit_date" field in this mutation.
func (m *GoodStatementMutation) AddedBenefitDate() (r int32, exists bool) {
	v := m.addbenefit_date
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitDate clears the value of the "benefit_date" field.
func (m *GoodStatementMutation) ClearBenefitDate() {
	m.benefit_date = nil
	m.addbenefit_date = nil
	m.clearedFields[goodstatement.FieldBenefitDate] = struct{}{}
}

// BenefitDateCleared returns if the "benefit_date" field was cleared in this mutation.
func (m *GoodStatementMutation) BenefitDateCleared() bool {
	_, ok := m.clearedFields[goodstatement.FieldBenefitDate]
	return ok
}

// ResetBenefitDate resets all changes to the "benefit_date" field.
func (m *GoodStatementMutation) ResetBenefitDate() {
	m.benefit_date = nil
	m.addbenefit_date = nil
	delete(m.clearedFields, goodstatement.FieldBenefitDate)
}

// Where appends a list predicates to the GoodStatementMutation builder.
func (m *GoodStatementMutation) Where(ps ...predicate.GoodStatement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodStatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodStatement).
func (m *GoodStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodStatementMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, goodstatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodstatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodstatement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, goodstatement.FieldEntID)
	}
	if m.good_id != nil {
		fields = append(fields, goodstatement.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, goodstatement.FieldCoinTypeID)
	}
	if m.amount != nil {
		fields = append(fields, goodstatement.FieldAmount)
	}
	if m.to_platform != nil {
		fields = append(fields, goodstatement.FieldToPlatform)
	}
	if m.to_user != nil {
		fields = append(fields, goodstatement.FieldToUser)
	}
	if m.technique_service_fee_amount != nil {
		fields = append(fields, goodstatement.FieldTechniqueServiceFeeAmount)
	}
	if m.benefit_date != nil {
		fields = append(fields, goodstatement.FieldBenefitDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodstatement.FieldCreatedAt:
		return m.CreatedAt()
	case goodstatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodstatement.FieldDeletedAt:
		return m.DeletedAt()
	case goodstatement.FieldEntID:
		return m.EntID()
	case goodstatement.FieldGoodID:
		return m.GoodID()
	case goodstatement.FieldCoinTypeID:
		return m.CoinTypeID()
	case goodstatement.FieldAmount:
		return m.Amount()
	case goodstatement.FieldToPlatform:
		return m.ToPlatform()
	case goodstatement.FieldToUser:
		return m.ToUser()
	case goodstatement.FieldTechniqueServiceFeeAmount:
		return m.TechniqueServiceFeeAmount()
	case goodstatement.FieldBenefitDate:
		return m.BenefitDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodstatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodstatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodstatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodstatement.FieldEntID:
		return m.OldEntID(ctx)
	case goodstatement.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodstatement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case goodstatement.FieldAmount:
		return m.OldAmount(ctx)
	case goodstatement.FieldToPlatform:
		return m.OldToPlatform(ctx)
	case goodstatement.FieldToUser:
		return m.OldToUser(ctx)
	case goodstatement.FieldTechniqueServiceFeeAmount:
		return m.OldTechniqueServiceFeeAmount(ctx)
	case goodstatement.FieldBenefitDate:
		return m.OldBenefitDate(ctx)
	}
	return nil, fmt.Errorf("unknown GoodStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodstatement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodstatement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodstatement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodstatement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodstatement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodstatement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case goodstatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case goodstatement.FieldToPlatform:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToPlatform(v)
		return nil
	case goodstatement.FieldToUser:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUser(v)
		return nil
	case goodstatement.FieldTechniqueServiceFeeAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechniqueServiceFeeAmount(v)
		return nil
	case goodstatement.FieldBenefitDate:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitDate(v)
		return nil
	}
	return fmt.Errorf("unknown GoodStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodstatement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodstatement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodstatement.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, goodstatement.FieldAmount)
	}
	if m.addto_platform != nil {
		fields = append(fields, goodstatement.FieldToPlatform)
	}
	if m.addto_user != nil {
		fields = append(fields, goodstatement.FieldToUser)
	}
	if m.addtechnique_service_fee_amount != nil {
		fields = append(fields, goodstatement.FieldTechniqueServiceFeeAmount)
	}
	if m.addbenefit_date != nil {
		fields = append(fields, goodstatement.FieldBenefitDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodstatement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodstatement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodstatement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodstatement.FieldAmount:
		return m.AddedAmount()
	case goodstatement.FieldToPlatform:
		return m.AddedToPlatform()
	case goodstatement.FieldToUser:
		return m.AddedToUser()
	case goodstatement.FieldTechniqueServiceFeeAmount:
		return m.AddedTechniqueServiceFeeAmount()
	case goodstatement.FieldBenefitDate:
		return m.AddedBenefitDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodstatement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodstatement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodstatement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodstatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case goodstatement.FieldToPlatform:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToPlatform(v)
		return nil
	case goodstatement.FieldToUser:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToUser(v)
		return nil
	case goodstatement.FieldTechniqueServiceFeeAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTechniqueServiceFeeAmount(v)
		return nil
	case goodstatement.FieldBenefitDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitDate(v)
		return nil
	}
	return fmt.Errorf("unknown GoodStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodstatement.FieldGoodID) {
		fields = append(fields, goodstatement.FieldGoodID)
	}
	if m.FieldCleared(goodstatement.FieldCoinTypeID) {
		fields = append(fields, goodstatement.FieldCoinTypeID)
	}
	if m.FieldCleared(goodstatement.FieldAmount) {
		fields = append(fields, goodstatement.FieldAmount)
	}
	if m.FieldCleared(goodstatement.FieldToPlatform) {
		fields = append(fields, goodstatement.FieldToPlatform)
	}
	if m.FieldCleared(goodstatement.FieldToUser) {
		fields = append(fields, goodstatement.FieldToUser)
	}
	if m.FieldCleared(goodstatement.FieldTechniqueServiceFeeAmount) {
		fields = append(fields, goodstatement.FieldTechniqueServiceFeeAmount)
	}
	if m.FieldCleared(goodstatement.FieldBenefitDate) {
		fields = append(fields, goodstatement.FieldBenefitDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodStatementMutation) ClearField(name string) error {
	switch name {
	case goodstatement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodstatement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case goodstatement.FieldAmount:
		m.ClearAmount()
		return nil
	case goodstatement.FieldToPlatform:
		m.ClearToPlatform()
		return nil
	case goodstatement.FieldToUser:
		m.ClearToUser()
		return nil
	case goodstatement.FieldTechniqueServiceFeeAmount:
		m.ClearTechniqueServiceFeeAmount()
		return nil
	case goodstatement.FieldBenefitDate:
		m.ClearBenefitDate()
		return nil
	}
	return fmt.Errorf("unknown GoodStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodStatementMutation) ResetField(name string) error {
	switch name {
	case goodstatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodstatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodstatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodstatement.FieldEntID:
		m.ResetEntID()
		return nil
	case goodstatement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodstatement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case goodstatement.FieldAmount:
		m.ResetAmount()
		return nil
	case goodstatement.FieldToPlatform:
		m.ResetToPlatform()
		return nil
	case goodstatement.FieldToUser:
		m.ResetToUser()
		return nil
	case goodstatement.FieldTechniqueServiceFeeAmount:
		m.ResetTechniqueServiceFeeAmount()
		return nil
	case goodstatement.FieldBenefitDate:
		m.ResetBenefitDate()
		return nil
	}
	return fmt.Errorf("unknown GoodStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodStatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodStatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodStatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodStatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodStatement edge %s", name)
}

// LedgerMutation represents an operation that mutates the Ledger nodes in the graph.
type LedgerMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	incoming      *decimal.Decimal
	addincoming   *decimal.Decimal
	locked        *decimal.Decimal
	addlocked     *decimal.Decimal
	outcoming     *decimal.Decimal
	addoutcoming  *decimal.Decimal
	spendable     *decimal.Decimal
	addspendable  *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Ledger, error)
	predicates    []predicate.Ledger
}

var _ ent.Mutation = (*LedgerMutation)(nil)

// ledgerOption allows management of the mutation configuration using functional options.
type ledgerOption func(*LedgerMutation)

// newLedgerMutation creates new mutation for the Ledger entity.
func newLedgerMutation(c config, op Op, opts ...ledgerOption) *LedgerMutation {
	m := &LedgerMutation{
		config:        c,
		op:            op,
		typ:           TypeLedger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerID sets the ID field of the mutation.
func withLedgerID(id uint32) ledgerOption {
	return func(m *LedgerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ledger
		)
		m.oldValue = func(ctx context.Context) (*Ledger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ledger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedger sets the old Ledger of the mutation.
func withLedger(node *Ledger) ledgerOption {
	return func(m *LedgerMutation) {
		m.oldValue = func(context.Context) (*Ledger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ledger entities.
func (m *LedgerMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ledger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LedgerMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LedgerMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LedgerMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LedgerMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LedgerMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LedgerMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LedgerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LedgerMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LedgerMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LedgerMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LedgerMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LedgerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *LedgerMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *LedgerMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *LedgerMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *LedgerMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *LedgerMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *LedgerMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[ledger.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *LedgerMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[ledger.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *LedgerMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, ledger.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *LedgerMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LedgerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LedgerMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[ledger.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LedgerMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[ledger.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LedgerMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, ledger.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *LedgerMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *LedgerMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *LedgerMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[ledger.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *LedgerMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[ledger.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *LedgerMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, ledger.FieldCoinTypeID)
}

// SetIncoming sets the "incoming" field.
func (m *LedgerMutation) SetIncoming(d decimal.Decimal) {
	m.incoming = &d
	m.addincoming = nil
}

// Incoming returns the value of the "incoming" field in the mutation.
func (m *LedgerMutation) Incoming() (r decimal.Decimal, exists bool) {
	v := m.incoming
	if v == nil {
		return
	}
	return *v, true
}

// OldIncoming returns the old "incoming" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldIncoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncoming: %w", err)
	}
	return oldValue.Incoming, nil
}

// AddIncoming adds d to the "incoming" field.
func (m *LedgerMutation) AddIncoming(d decimal.Decimal) {
	if m.addincoming != nil {
		*m.addincoming = m.addincoming.Add(d)
	} else {
		m.addincoming = &d
	}
}

// AddedIncoming returns the value that was added to the "incoming" field in this mutation.
func (m *LedgerMutation) AddedIncoming() (r decimal.Decimal, exists bool) {
	v := m.addincoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncoming clears the value of the "incoming" field.
func (m *LedgerMutation) ClearIncoming() {
	m.incoming = nil
	m.addincoming = nil
	m.clearedFields[ledger.FieldIncoming] = struct{}{}
}

// IncomingCleared returns if the "incoming" field was cleared in this mutation.
func (m *LedgerMutation) IncomingCleared() bool {
	_, ok := m.clearedFields[ledger.FieldIncoming]
	return ok
}

// ResetIncoming resets all changes to the "incoming" field.
func (m *LedgerMutation) ResetIncoming() {
	m.incoming = nil
	m.addincoming = nil
	delete(m.clearedFields, ledger.FieldIncoming)
}

// SetLocked sets the "locked" field.
func (m *LedgerMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
	m.addlocked = nil
}

// Locked returns the value of the "locked" field in the mutation.
func (m *LedgerMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// AddLocked adds d to the "locked" field.
func (m *LedgerMutation) AddLocked(d decimal.Decimal) {
	if m.addlocked != nil {
		*m.addlocked = m.addlocked.Add(d)
	} else {
		m.addlocked = &d
	}
}

// AddedLocked returns the value that was added to the "locked" field in this mutation.
func (m *LedgerMutation) AddedLocked() (r decimal.Decimal, exists bool) {
	v := m.addlocked
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocked clears the value of the "locked" field.
func (m *LedgerMutation) ClearLocked() {
	m.locked = nil
	m.addlocked = nil
	m.clearedFields[ledger.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *LedgerMutation) LockedCleared() bool {
	_, ok := m.clearedFields[ledger.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *LedgerMutation) ResetLocked() {
	m.locked = nil
	m.addlocked = nil
	delete(m.clearedFields, ledger.FieldLocked)
}

// SetOutcoming sets the "outcoming" field.
func (m *LedgerMutation) SetOutcoming(d decimal.Decimal) {
	m.outcoming = &d
	m.addoutcoming = nil
}

// Outcoming returns the value of the "outcoming" field in the mutation.
func (m *LedgerMutation) Outcoming() (r decimal.Decimal, exists bool) {
	v := m.outcoming
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcoming returns the old "outcoming" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldOutcoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcoming: %w", err)
	}
	return oldValue.Outcoming, nil
}

// AddOutcoming adds d to the "outcoming" field.
func (m *LedgerMutation) AddOutcoming(d decimal.Decimal) {
	if m.addoutcoming != nil {
		*m.addoutcoming = m.addoutcoming.Add(d)
	} else {
		m.addoutcoming = &d
	}
}

// AddedOutcoming returns the value that was added to the "outcoming" field in this mutation.
func (m *LedgerMutation) AddedOutcoming() (r decimal.Decimal, exists bool) {
	v := m.addoutcoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutcoming clears the value of the "outcoming" field.
func (m *LedgerMutation) ClearOutcoming() {
	m.outcoming = nil
	m.addoutcoming = nil
	m.clearedFields[ledger.FieldOutcoming] = struct{}{}
}

// OutcomingCleared returns if the "outcoming" field was cleared in this mutation.
func (m *LedgerMutation) OutcomingCleared() bool {
	_, ok := m.clearedFields[ledger.FieldOutcoming]
	return ok
}

// ResetOutcoming resets all changes to the "outcoming" field.
func (m *LedgerMutation) ResetOutcoming() {
	m.outcoming = nil
	m.addoutcoming = nil
	delete(m.clearedFields, ledger.FieldOutcoming)
}

// SetSpendable sets the "spendable" field.
func (m *LedgerMutation) SetSpendable(d decimal.Decimal) {
	m.spendable = &d
	m.addspendable = nil
}

// Spendable returns the value of the "spendable" field in the mutation.
func (m *LedgerMutation) Spendable() (r decimal.Decimal, exists bool) {
	v := m.spendable
	if v == nil {
		return
	}
	return *v, true
}

// OldSpendable returns the old "spendable" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldSpendable(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpendable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpendable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpendable: %w", err)
	}
	return oldValue.Spendable, nil
}

// AddSpendable adds d to the "spendable" field.
func (m *LedgerMutation) AddSpendable(d decimal.Decimal) {
	if m.addspendable != nil {
		*m.addspendable = m.addspendable.Add(d)
	} else {
		m.addspendable = &d
	}
}

// AddedSpendable returns the value that was added to the "spendable" field in this mutation.
func (m *LedgerMutation) AddedSpendable() (r decimal.Decimal, exists bool) {
	v := m.addspendable
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpendable clears the value of the "spendable" field.
func (m *LedgerMutation) ClearSpendable() {
	m.spendable = nil
	m.addspendable = nil
	m.clearedFields[ledger.FieldSpendable] = struct{}{}
}

// SpendableCleared returns if the "spendable" field was cleared in this mutation.
func (m *LedgerMutation) SpendableCleared() bool {
	_, ok := m.clearedFields[ledger.FieldSpendable]
	return ok
}

// ResetSpendable resets all changes to the "spendable" field.
func (m *LedgerMutation) ResetSpendable() {
	m.spendable = nil
	m.addspendable = nil
	delete(m.clearedFields, ledger.FieldSpendable)
}

// Where appends a list predicates to the LedgerMutation builder.
func (m *LedgerMutation) Where(ps ...predicate.Ledger) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LedgerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ledger).
func (m *LedgerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, ledger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ledger.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ledger.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, ledger.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, ledger.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, ledger.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, ledger.FieldCoinTypeID)
	}
	if m.incoming != nil {
		fields = append(fields, ledger.FieldIncoming)
	}
	if m.locked != nil {
		fields = append(fields, ledger.FieldLocked)
	}
	if m.outcoming != nil {
		fields = append(fields, ledger.FieldOutcoming)
	}
	if m.spendable != nil {
		fields = append(fields, ledger.FieldSpendable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledger.FieldCreatedAt:
		return m.CreatedAt()
	case ledger.FieldUpdatedAt:
		return m.UpdatedAt()
	case ledger.FieldDeletedAt:
		return m.DeletedAt()
	case ledger.FieldEntID:
		return m.EntID()
	case ledger.FieldAppID:
		return m.AppID()
	case ledger.FieldUserID:
		return m.UserID()
	case ledger.FieldCoinTypeID:
		return m.CoinTypeID()
	case ledger.FieldIncoming:
		return m.Incoming()
	case ledger.FieldLocked:
		return m.Locked()
	case ledger.FieldOutcoming:
		return m.Outcoming()
	case ledger.FieldSpendable:
		return m.Spendable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ledger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ledger.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ledger.FieldEntID:
		return m.OldEntID(ctx)
	case ledger.FieldAppID:
		return m.OldAppID(ctx)
	case ledger.FieldUserID:
		return m.OldUserID(ctx)
	case ledger.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case ledger.FieldIncoming:
		return m.OldIncoming(ctx)
	case ledger.FieldLocked:
		return m.OldLocked(ctx)
	case ledger.FieldOutcoming:
		return m.OldOutcoming(ctx)
	case ledger.FieldSpendable:
		return m.OldSpendable(ctx)
	}
	return nil, fmt.Errorf("unknown Ledger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledger.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ledger.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ledger.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ledger.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case ledger.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case ledger.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ledger.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case ledger.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncoming(v)
		return nil
	case ledger.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case ledger.FieldOutcoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcoming(v)
		return nil
	case ledger.FieldSpendable:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpendable(v)
		return nil
	}
	return fmt.Errorf("unknown Ledger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, ledger.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, ledger.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, ledger.FieldDeletedAt)
	}
	if m.addincoming != nil {
		fields = append(fields, ledger.FieldIncoming)
	}
	if m.addlocked != nil {
		fields = append(fields, ledger.FieldLocked)
	}
	if m.addoutcoming != nil {
		fields = append(fields, ledger.FieldOutcoming)
	}
	if m.addspendable != nil {
		fields = append(fields, ledger.FieldSpendable)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledger.FieldCreatedAt:
		return m.AddedCreatedAt()
	case ledger.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case ledger.FieldDeletedAt:
		return m.AddedDeletedAt()
	case ledger.FieldIncoming:
		return m.AddedIncoming()
	case ledger.FieldLocked:
		return m.AddedLocked()
	case ledger.FieldOutcoming:
		return m.AddedOutcoming()
	case ledger.FieldSpendable:
		return m.AddedSpendable()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledger.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case ledger.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case ledger.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case ledger.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncoming(v)
		return nil
	case ledger.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocked(v)
		return nil
	case ledger.FieldOutcoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcoming(v)
		return nil
	case ledger.FieldSpendable:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpendable(v)
		return nil
	}
	return fmt.Errorf("unknown Ledger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ledger.FieldAppID) {
		fields = append(fields, ledger.FieldAppID)
	}
	if m.FieldCleared(ledger.FieldUserID) {
		fields = append(fields, ledger.FieldUserID)
	}
	if m.FieldCleared(ledger.FieldCoinTypeID) {
		fields = append(fields, ledger.FieldCoinTypeID)
	}
	if m.FieldCleared(ledger.FieldIncoming) {
		fields = append(fields, ledger.FieldIncoming)
	}
	if m.FieldCleared(ledger.FieldLocked) {
		fields = append(fields, ledger.FieldLocked)
	}
	if m.FieldCleared(ledger.FieldOutcoming) {
		fields = append(fields, ledger.FieldOutcoming)
	}
	if m.FieldCleared(ledger.FieldSpendable) {
		fields = append(fields, ledger.FieldSpendable)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerMutation) ClearField(name string) error {
	switch name {
	case ledger.FieldAppID:
		m.ClearAppID()
		return nil
	case ledger.FieldUserID:
		m.ClearUserID()
		return nil
	case ledger.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case ledger.FieldIncoming:
		m.ClearIncoming()
		return nil
	case ledger.FieldLocked:
		m.ClearLocked()
		return nil
	case ledger.FieldOutcoming:
		m.ClearOutcoming()
		return nil
	case ledger.FieldSpendable:
		m.ClearSpendable()
		return nil
	}
	return fmt.Errorf("unknown Ledger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerMutation) ResetField(name string) error {
	switch name {
	case ledger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ledger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ledger.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ledger.FieldEntID:
		m.ResetEntID()
		return nil
	case ledger.FieldAppID:
		m.ResetAppID()
		return nil
	case ledger.FieldUserID:
		m.ResetUserID()
		return nil
	case ledger.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case ledger.FieldIncoming:
		m.ResetIncoming()
		return nil
	case ledger.FieldLocked:
		m.ResetLocked()
		return nil
	case ledger.FieldOutcoming:
		m.ResetOutcoming()
		return nil
	case ledger.FieldSpendable:
		m.ResetSpendable()
		return nil
	}
	return fmt.Errorf("unknown Ledger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ledger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ledger edge %s", name)
}

// LedgerLockMutation represents an operation that mutates the LedgerLock nodes in the graph.
type LedgerLockMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	ledger_id     *uuid.UUID
	statement_id  *uuid.UUID
	amount        *decimal.Decimal
	addamount     *decimal.Decimal
	lock_state    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LedgerLock, error)
	predicates    []predicate.LedgerLock
}

var _ ent.Mutation = (*LedgerLockMutation)(nil)

// ledgerlockOption allows management of the mutation configuration using functional options.
type ledgerlockOption func(*LedgerLockMutation)

// newLedgerLockMutation creates new mutation for the LedgerLock entity.
func newLedgerLockMutation(c config, op Op, opts ...ledgerlockOption) *LedgerLockMutation {
	m := &LedgerLockMutation{
		config:        c,
		op:            op,
		typ:           TypeLedgerLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerLockID sets the ID field of the mutation.
func withLedgerLockID(id uint32) ledgerlockOption {
	return func(m *LedgerLockMutation) {
		var (
			err   error
			once  sync.Once
			value *LedgerLock
		)
		m.oldValue = func(ctx context.Context) (*LedgerLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LedgerLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedgerLock sets the old LedgerLock of the mutation.
func withLedgerLock(node *LedgerLock) ledgerlockOption {
	return func(m *LedgerLockMutation) {
		m.oldValue = func(context.Context) (*LedgerLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LedgerLock entities.
func (m *LedgerLockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerLockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerLockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LedgerLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerLockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerLockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LedgerLockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LedgerLockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerLockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LedgerLockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LedgerLockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LedgerLockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LedgerLockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LedgerLockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LedgerLockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LedgerLockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LedgerLockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LedgerLockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LedgerLockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *LedgerLockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *LedgerLockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *LedgerLockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetLedgerID sets the "ledger_id" field.
func (m *LedgerLockMutation) SetLedgerID(u uuid.UUID) {
	m.ledger_id = &u
}

// LedgerID returns the value of the "ledger_id" field in the mutation.
func (m *LedgerLockMutation) LedgerID() (r uuid.UUID, exists bool) {
	v := m.ledger_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLedgerID returns the old "ledger_id" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldLedgerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLedgerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLedgerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLedgerID: %w", err)
	}
	return oldValue.LedgerID, nil
}

// ClearLedgerID clears the value of the "ledger_id" field.
func (m *LedgerLockMutation) ClearLedgerID() {
	m.ledger_id = nil
	m.clearedFields[ledgerlock.FieldLedgerID] = struct{}{}
}

// LedgerIDCleared returns if the "ledger_id" field was cleared in this mutation.
func (m *LedgerLockMutation) LedgerIDCleared() bool {
	_, ok := m.clearedFields[ledgerlock.FieldLedgerID]
	return ok
}

// ResetLedgerID resets all changes to the "ledger_id" field.
func (m *LedgerLockMutation) ResetLedgerID() {
	m.ledger_id = nil
	delete(m.clearedFields, ledgerlock.FieldLedgerID)
}

// SetStatementID sets the "statement_id" field.
func (m *LedgerLockMutation) SetStatementID(u uuid.UUID) {
	m.statement_id = &u
}

// StatementID returns the value of the "statement_id" field in the mutation.
func (m *LedgerLockMutation) StatementID() (r uuid.UUID, exists bool) {
	v := m.statement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementID returns the old "statement_id" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldStatementID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementID: %w", err)
	}
	return oldValue.StatementID, nil
}

// ClearStatementID clears the value of the "statement_id" field.
func (m *LedgerLockMutation) ClearStatementID() {
	m.statement_id = nil
	m.clearedFields[ledgerlock.FieldStatementID] = struct{}{}
}

// StatementIDCleared returns if the "statement_id" field was cleared in this mutation.
func (m *LedgerLockMutation) StatementIDCleared() bool {
	_, ok := m.clearedFields[ledgerlock.FieldStatementID]
	return ok
}

// ResetStatementID resets all changes to the "statement_id" field.
func (m *LedgerLockMutation) ResetStatementID() {
	m.statement_id = nil
	delete(m.clearedFields, ledgerlock.FieldStatementID)
}

// SetAmount sets the "amount" field.
func (m *LedgerLockMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LedgerLockMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *LedgerLockMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LedgerLockMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *LedgerLockMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[ledgerlock.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *LedgerLockMutation) AmountCleared() bool {
	_, ok := m.clearedFields[ledgerlock.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *LedgerLockMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, ledgerlock.FieldAmount)
}

// SetLockState sets the "lock_state" field.
func (m *LedgerLockMutation) SetLockState(s string) {
	m.lock_state = &s
}

// LockState returns the value of the "lock_state" field in the mutation.
func (m *LedgerLockMutation) LockState() (r string, exists bool) {
	v := m.lock_state
	if v == nil {
		return
	}
	return *v, true
}

// OldLockState returns the old "lock_state" field's value of the LedgerLock entity.
// If the LedgerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerLockMutation) OldLockState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockState: %w", err)
	}
	return oldValue.LockState, nil
}

// ClearLockState clears the value of the "lock_state" field.
func (m *LedgerLockMutation) ClearLockState() {
	m.lock_state = nil
	m.clearedFields[ledgerlock.FieldLockState] = struct{}{}
}

// LockStateCleared returns if the "lock_state" field was cleared in this mutation.
func (m *LedgerLockMutation) LockStateCleared() bool {
	_, ok := m.clearedFields[ledgerlock.FieldLockState]
	return ok
}

// ResetLockState resets all changes to the "lock_state" field.
func (m *LedgerLockMutation) ResetLockState() {
	m.lock_state = nil
	delete(m.clearedFields, ledgerlock.FieldLockState)
}

// Where appends a list predicates to the LedgerLockMutation builder.
func (m *LedgerLockMutation) Where(ps ...predicate.LedgerLock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LedgerLockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LedgerLock).
func (m *LedgerLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerLockMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, ledgerlock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ledgerlock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ledgerlock.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, ledgerlock.FieldEntID)
	}
	if m.ledger_id != nil {
		fields = append(fields, ledgerlock.FieldLedgerID)
	}
	if m.statement_id != nil {
		fields = append(fields, ledgerlock.FieldStatementID)
	}
	if m.amount != nil {
		fields = append(fields, ledgerlock.FieldAmount)
	}
	if m.lock_state != nil {
		fields = append(fields, ledgerlock.FieldLockState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledgerlock.FieldCreatedAt:
		return m.CreatedAt()
	case ledgerlock.FieldUpdatedAt:
		return m.UpdatedAt()
	case ledgerlock.FieldDeletedAt:
		return m.DeletedAt()
	case ledgerlock.FieldEntID:
		return m.EntID()
	case ledgerlock.FieldLedgerID:
		return m.LedgerID()
	case ledgerlock.FieldStatementID:
		return m.StatementID()
	case ledgerlock.FieldAmount:
		return m.Amount()
	case ledgerlock.FieldLockState:
		return m.LockState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledgerlock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ledgerlock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ledgerlock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ledgerlock.FieldEntID:
		return m.OldEntID(ctx)
	case ledgerlock.FieldLedgerID:
		return m.OldLedgerID(ctx)
	case ledgerlock.FieldStatementID:
		return m.OldStatementID(ctx)
	case ledgerlock.FieldAmount:
		return m.OldAmount(ctx)
	case ledgerlock.FieldLockState:
		return m.OldLockState(ctx)
	}
	return nil, fmt.Errorf("unknown LedgerLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledgerlock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ledgerlock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ledgerlock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ledgerlock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case ledgerlock.FieldLedgerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLedgerID(v)
		return nil
	case ledgerlock.FieldStatementID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementID(v)
		return nil
	case ledgerlock.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case ledgerlock.FieldLockState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockState(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerLockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, ledgerlock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, ledgerlock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, ledgerlock.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, ledgerlock.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledgerlock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case ledgerlock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case ledgerlock.FieldDeletedAt:
		return m.AddedDeletedAt()
	case ledgerlock.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledgerlock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case ledgerlock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case ledgerlock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case ledgerlock.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ledgerlock.FieldLedgerID) {
		fields = append(fields, ledgerlock.FieldLedgerID)
	}
	if m.FieldCleared(ledgerlock.FieldStatementID) {
		fields = append(fields, ledgerlock.FieldStatementID)
	}
	if m.FieldCleared(ledgerlock.FieldAmount) {
		fields = append(fields, ledgerlock.FieldAmount)
	}
	if m.FieldCleared(ledgerlock.FieldLockState) {
		fields = append(fields, ledgerlock.FieldLockState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerLockMutation) ClearField(name string) error {
	switch name {
	case ledgerlock.FieldLedgerID:
		m.ClearLedgerID()
		return nil
	case ledgerlock.FieldStatementID:
		m.ClearStatementID()
		return nil
	case ledgerlock.FieldAmount:
		m.ClearAmount()
		return nil
	case ledgerlock.FieldLockState:
		m.ClearLockState()
		return nil
	}
	return fmt.Errorf("unknown LedgerLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerLockMutation) ResetField(name string) error {
	switch name {
	case ledgerlock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ledgerlock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ledgerlock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ledgerlock.FieldEntID:
		m.ResetEntID()
		return nil
	case ledgerlock.FieldLedgerID:
		m.ResetLedgerID()
		return nil
	case ledgerlock.FieldStatementID:
		m.ResetStatementID()
		return nil
	case ledgerlock.FieldAmount:
		m.ResetAmount()
		return nil
	case ledgerlock.FieldLockState:
		m.ResetLockState()
		return nil
	}
	return fmt.Errorf("unknown LedgerLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LedgerLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LedgerLock edge %s", name)
}

// ProfitMutation represents an operation that mutates the Profit nodes in the graph.
type ProfitMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	incoming      *decimal.Decimal
	addincoming   *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Profit, error)
	predicates    []predicate.Profit
}

var _ ent.Mutation = (*ProfitMutation)(nil)

// profitOption allows management of the mutation configuration using functional options.
type profitOption func(*ProfitMutation)

// newProfitMutation creates new mutation for the Profit entity.
func newProfitMutation(c config, op Op, opts ...profitOption) *ProfitMutation {
	m := &ProfitMutation{
		config:        c,
		op:            op,
		typ:           TypeProfit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitID sets the ID field of the mutation.
func withProfitID(id uint32) profitOption {
	return func(m *ProfitMutation) {
		var (
			err   error
			once  sync.Once
			value *Profit
		)
		m.oldValue = func(ctx context.Context) (*Profit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfit sets the old Profit of the mutation.
func withProfit(node *Profit) profitOption {
	return func(m *ProfitMutation) {
		m.oldValue = func(context.Context) (*Profit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profit entities.
func (m *ProfitMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfitMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfitMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ProfitMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ProfitMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfitMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfitMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfitMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ProfitMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ProfitMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfitMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfitMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ProfitMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProfitMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *ProfitMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *ProfitMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *ProfitMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *ProfitMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ProfitMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *ProfitMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[profit.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *ProfitMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[profit.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ProfitMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, profit.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *ProfitMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfitMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ProfitMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[profit.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ProfitMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[profit.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfitMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, profit.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *ProfitMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *ProfitMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *ProfitMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[profit.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *ProfitMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[profit.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *ProfitMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, profit.FieldCoinTypeID)
}

// SetIncoming sets the "incoming" field.
func (m *ProfitMutation) SetIncoming(d decimal.Decimal) {
	m.incoming = &d
	m.addincoming = nil
}

// Incoming returns the value of the "incoming" field in the mutation.
func (m *ProfitMutation) Incoming() (r decimal.Decimal, exists bool) {
	v := m.incoming
	if v == nil {
		return
	}
	return *v, true
}

// OldIncoming returns the old "incoming" field's value of the Profit entity.
// If the Profit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitMutation) OldIncoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncoming: %w", err)
	}
	return oldValue.Incoming, nil
}

// AddIncoming adds d to the "incoming" field.
func (m *ProfitMutation) AddIncoming(d decimal.Decimal) {
	if m.addincoming != nil {
		*m.addincoming = m.addincoming.Add(d)
	} else {
		m.addincoming = &d
	}
}

// AddedIncoming returns the value that was added to the "incoming" field in this mutation.
func (m *ProfitMutation) AddedIncoming() (r decimal.Decimal, exists bool) {
	v := m.addincoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncoming clears the value of the "incoming" field.
func (m *ProfitMutation) ClearIncoming() {
	m.incoming = nil
	m.addincoming = nil
	m.clearedFields[profit.FieldIncoming] = struct{}{}
}

// IncomingCleared returns if the "incoming" field was cleared in this mutation.
func (m *ProfitMutation) IncomingCleared() bool {
	_, ok := m.clearedFields[profit.FieldIncoming]
	return ok
}

// ResetIncoming resets all changes to the "incoming" field.
func (m *ProfitMutation) ResetIncoming() {
	m.incoming = nil
	m.addincoming = nil
	delete(m.clearedFields, profit.FieldIncoming)
}

// Where appends a list predicates to the ProfitMutation builder.
func (m *ProfitMutation) Where(ps ...predicate.Profit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProfitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Profit).
func (m *ProfitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, profit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profit.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, profit.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, profit.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, profit.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, profit.FieldCoinTypeID)
	}
	if m.incoming != nil {
		fields = append(fields, profit.FieldIncoming)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profit.FieldCreatedAt:
		return m.CreatedAt()
	case profit.FieldUpdatedAt:
		return m.UpdatedAt()
	case profit.FieldDeletedAt:
		return m.DeletedAt()
	case profit.FieldEntID:
		return m.EntID()
	case profit.FieldAppID:
		return m.AppID()
	case profit.FieldUserID:
		return m.UserID()
	case profit.FieldCoinTypeID:
		return m.CoinTypeID()
	case profit.FieldIncoming:
		return m.Incoming()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case profit.FieldEntID:
		return m.OldEntID(ctx)
	case profit.FieldAppID:
		return m.OldAppID(ctx)
	case profit.FieldUserID:
		return m.OldUserID(ctx)
	case profit.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case profit.FieldIncoming:
		return m.OldIncoming(ctx)
	}
	return nil, fmt.Errorf("unknown Profit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profit.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profit.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profit.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case profit.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case profit.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case profit.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profit.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case profit.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncoming(v)
		return nil
	}
	return fmt.Errorf("unknown Profit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, profit.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, profit.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, profit.FieldDeletedAt)
	}
	if m.addincoming != nil {
		fields = append(fields, profit.FieldIncoming)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profit.FieldCreatedAt:
		return m.AddedCreatedAt()
	case profit.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case profit.FieldDeletedAt:
		return m.AddedDeletedAt()
	case profit.FieldIncoming:
		return m.AddedIncoming()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profit.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case profit.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case profit.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case profit.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncoming(v)
		return nil
	}
	return fmt.Errorf("unknown Profit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profit.FieldAppID) {
		fields = append(fields, profit.FieldAppID)
	}
	if m.FieldCleared(profit.FieldUserID) {
		fields = append(fields, profit.FieldUserID)
	}
	if m.FieldCleared(profit.FieldCoinTypeID) {
		fields = append(fields, profit.FieldCoinTypeID)
	}
	if m.FieldCleared(profit.FieldIncoming) {
		fields = append(fields, profit.FieldIncoming)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitMutation) ClearField(name string) error {
	switch name {
	case profit.FieldAppID:
		m.ClearAppID()
		return nil
	case profit.FieldUserID:
		m.ClearUserID()
		return nil
	case profit.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case profit.FieldIncoming:
		m.ClearIncoming()
		return nil
	}
	return fmt.Errorf("unknown Profit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitMutation) ResetField(name string) error {
	switch name {
	case profit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case profit.FieldEntID:
		m.ResetEntID()
		return nil
	case profit.FieldAppID:
		m.ResetAppID()
		return nil
	case profit.FieldUserID:
		m.ResetUserID()
		return nil
	case profit.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case profit.FieldIncoming:
		m.ResetIncoming()
		return nil
	}
	return fmt.Errorf("unknown Profit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Profit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Profit edge %s", name)
}

// SimulateLedgerMutation represents an operation that mutates the SimulateLedger nodes in the graph.
type SimulateLedgerMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	incoming      *decimal.Decimal
	addincoming   *decimal.Decimal
	outcoming     *decimal.Decimal
	addoutcoming  *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SimulateLedger, error)
	predicates    []predicate.SimulateLedger
}

var _ ent.Mutation = (*SimulateLedgerMutation)(nil)

// simulateledgerOption allows management of the mutation configuration using functional options.
type simulateledgerOption func(*SimulateLedgerMutation)

// newSimulateLedgerMutation creates new mutation for the SimulateLedger entity.
func newSimulateLedgerMutation(c config, op Op, opts ...simulateledgerOption) *SimulateLedgerMutation {
	m := &SimulateLedgerMutation{
		config:        c,
		op:            op,
		typ:           TypeSimulateLedger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSimulateLedgerID sets the ID field of the mutation.
func withSimulateLedgerID(id uint32) simulateledgerOption {
	return func(m *SimulateLedgerMutation) {
		var (
			err   error
			once  sync.Once
			value *SimulateLedger
		)
		m.oldValue = func(ctx context.Context) (*SimulateLedger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SimulateLedger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSimulateLedger sets the old SimulateLedger of the mutation.
func withSimulateLedger(node *SimulateLedger) simulateledgerOption {
	return func(m *SimulateLedgerMutation) {
		m.oldValue = func(context.Context) (*SimulateLedger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SimulateLedgerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SimulateLedgerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SimulateLedger entities.
func (m *SimulateLedgerMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SimulateLedgerMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SimulateLedgerMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SimulateLedger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SimulateLedgerMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SimulateLedgerMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SimulateLedgerMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SimulateLedgerMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SimulateLedgerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SimulateLedgerMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SimulateLedgerMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SimulateLedgerMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SimulateLedgerMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SimulateLedgerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SimulateLedgerMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SimulateLedgerMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SimulateLedgerMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SimulateLedgerMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SimulateLedgerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *SimulateLedgerMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SimulateLedgerMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SimulateLedgerMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SimulateLedgerMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SimulateLedgerMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SimulateLedgerMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[simulateledger.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SimulateLedgerMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[simulateledger.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SimulateLedgerMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, simulateledger.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *SimulateLedgerMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SimulateLedgerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SimulateLedgerMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[simulateledger.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SimulateLedgerMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[simulateledger.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SimulateLedgerMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, simulateledger.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *SimulateLedgerMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *SimulateLedgerMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *SimulateLedgerMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[simulateledger.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *SimulateLedgerMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[simulateledger.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *SimulateLedgerMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, simulateledger.FieldCoinTypeID)
}

// SetIncoming sets the "incoming" field.
func (m *SimulateLedgerMutation) SetIncoming(d decimal.Decimal) {
	m.incoming = &d
	m.addincoming = nil
}

// Incoming returns the value of the "incoming" field in the mutation.
func (m *SimulateLedgerMutation) Incoming() (r decimal.Decimal, exists bool) {
	v := m.incoming
	if v == nil {
		return
	}
	return *v, true
}

// OldIncoming returns the old "incoming" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldIncoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncoming: %w", err)
	}
	return oldValue.Incoming, nil
}

// AddIncoming adds d to the "incoming" field.
func (m *SimulateLedgerMutation) AddIncoming(d decimal.Decimal) {
	if m.addincoming != nil {
		*m.addincoming = m.addincoming.Add(d)
	} else {
		m.addincoming = &d
	}
}

// AddedIncoming returns the value that was added to the "incoming" field in this mutation.
func (m *SimulateLedgerMutation) AddedIncoming() (r decimal.Decimal, exists bool) {
	v := m.addincoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncoming clears the value of the "incoming" field.
func (m *SimulateLedgerMutation) ClearIncoming() {
	m.incoming = nil
	m.addincoming = nil
	m.clearedFields[simulateledger.FieldIncoming] = struct{}{}
}

// IncomingCleared returns if the "incoming" field was cleared in this mutation.
func (m *SimulateLedgerMutation) IncomingCleared() bool {
	_, ok := m.clearedFields[simulateledger.FieldIncoming]
	return ok
}

// ResetIncoming resets all changes to the "incoming" field.
func (m *SimulateLedgerMutation) ResetIncoming() {
	m.incoming = nil
	m.addincoming = nil
	delete(m.clearedFields, simulateledger.FieldIncoming)
}

// SetOutcoming sets the "outcoming" field.
func (m *SimulateLedgerMutation) SetOutcoming(d decimal.Decimal) {
	m.outcoming = &d
	m.addoutcoming = nil
}

// Outcoming returns the value of the "outcoming" field in the mutation.
func (m *SimulateLedgerMutation) Outcoming() (r decimal.Decimal, exists bool) {
	v := m.outcoming
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcoming returns the old "outcoming" field's value of the SimulateLedger entity.
// If the SimulateLedger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateLedgerMutation) OldOutcoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcoming: %w", err)
	}
	return oldValue.Outcoming, nil
}

// AddOutcoming adds d to the "outcoming" field.
func (m *SimulateLedgerMutation) AddOutcoming(d decimal.Decimal) {
	if m.addoutcoming != nil {
		*m.addoutcoming = m.addoutcoming.Add(d)
	} else {
		m.addoutcoming = &d
	}
}

// AddedOutcoming returns the value that was added to the "outcoming" field in this mutation.
func (m *SimulateLedgerMutation) AddedOutcoming() (r decimal.Decimal, exists bool) {
	v := m.addoutcoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutcoming clears the value of the "outcoming" field.
func (m *SimulateLedgerMutation) ClearOutcoming() {
	m.outcoming = nil
	m.addoutcoming = nil
	m.clearedFields[simulateledger.FieldOutcoming] = struct{}{}
}

// OutcomingCleared returns if the "outcoming" field was cleared in this mutation.
func (m *SimulateLedgerMutation) OutcomingCleared() bool {
	_, ok := m.clearedFields[simulateledger.FieldOutcoming]
	return ok
}

// ResetOutcoming resets all changes to the "outcoming" field.
func (m *SimulateLedgerMutation) ResetOutcoming() {
	m.outcoming = nil
	m.addoutcoming = nil
	delete(m.clearedFields, simulateledger.FieldOutcoming)
}

// Where appends a list predicates to the SimulateLedgerMutation builder.
func (m *SimulateLedgerMutation) Where(ps ...predicate.SimulateLedger) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SimulateLedgerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SimulateLedger).
func (m *SimulateLedgerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SimulateLedgerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, simulateledger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, simulateledger.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, simulateledger.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, simulateledger.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, simulateledger.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, simulateledger.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, simulateledger.FieldCoinTypeID)
	}
	if m.incoming != nil {
		fields = append(fields, simulateledger.FieldIncoming)
	}
	if m.outcoming != nil {
		fields = append(fields, simulateledger.FieldOutcoming)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SimulateLedgerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case simulateledger.FieldCreatedAt:
		return m.CreatedAt()
	case simulateledger.FieldUpdatedAt:
		return m.UpdatedAt()
	case simulateledger.FieldDeletedAt:
		return m.DeletedAt()
	case simulateledger.FieldEntID:
		return m.EntID()
	case simulateledger.FieldAppID:
		return m.AppID()
	case simulateledger.FieldUserID:
		return m.UserID()
	case simulateledger.FieldCoinTypeID:
		return m.CoinTypeID()
	case simulateledger.FieldIncoming:
		return m.Incoming()
	case simulateledger.FieldOutcoming:
		return m.Outcoming()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SimulateLedgerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case simulateledger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case simulateledger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case simulateledger.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case simulateledger.FieldEntID:
		return m.OldEntID(ctx)
	case simulateledger.FieldAppID:
		return m.OldAppID(ctx)
	case simulateledger.FieldUserID:
		return m.OldUserID(ctx)
	case simulateledger.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case simulateledger.FieldIncoming:
		return m.OldIncoming(ctx)
	case simulateledger.FieldOutcoming:
		return m.OldOutcoming(ctx)
	}
	return nil, fmt.Errorf("unknown SimulateLedger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateLedgerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case simulateledger.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case simulateledger.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case simulateledger.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case simulateledger.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case simulateledger.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case simulateledger.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case simulateledger.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case simulateledger.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncoming(v)
		return nil
	case simulateledger.FieldOutcoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcoming(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateLedger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SimulateLedgerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, simulateledger.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, simulateledger.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, simulateledger.FieldDeletedAt)
	}
	if m.addincoming != nil {
		fields = append(fields, simulateledger.FieldIncoming)
	}
	if m.addoutcoming != nil {
		fields = append(fields, simulateledger.FieldOutcoming)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SimulateLedgerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case simulateledger.FieldCreatedAt:
		return m.AddedCreatedAt()
	case simulateledger.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case simulateledger.FieldDeletedAt:
		return m.AddedDeletedAt()
	case simulateledger.FieldIncoming:
		return m.AddedIncoming()
	case simulateledger.FieldOutcoming:
		return m.AddedOutcoming()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateLedgerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case simulateledger.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case simulateledger.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case simulateledger.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case simulateledger.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncoming(v)
		return nil
	case simulateledger.FieldOutcoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcoming(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateLedger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SimulateLedgerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(simulateledger.FieldAppID) {
		fields = append(fields, simulateledger.FieldAppID)
	}
	if m.FieldCleared(simulateledger.FieldUserID) {
		fields = append(fields, simulateledger.FieldUserID)
	}
	if m.FieldCleared(simulateledger.FieldCoinTypeID) {
		fields = append(fields, simulateledger.FieldCoinTypeID)
	}
	if m.FieldCleared(simulateledger.FieldIncoming) {
		fields = append(fields, simulateledger.FieldIncoming)
	}
	if m.FieldCleared(simulateledger.FieldOutcoming) {
		fields = append(fields, simulateledger.FieldOutcoming)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SimulateLedgerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SimulateLedgerMutation) ClearField(name string) error {
	switch name {
	case simulateledger.FieldAppID:
		m.ClearAppID()
		return nil
	case simulateledger.FieldUserID:
		m.ClearUserID()
		return nil
	case simulateledger.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case simulateledger.FieldIncoming:
		m.ClearIncoming()
		return nil
	case simulateledger.FieldOutcoming:
		m.ClearOutcoming()
		return nil
	}
	return fmt.Errorf("unknown SimulateLedger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SimulateLedgerMutation) ResetField(name string) error {
	switch name {
	case simulateledger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case simulateledger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case simulateledger.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case simulateledger.FieldEntID:
		m.ResetEntID()
		return nil
	case simulateledger.FieldAppID:
		m.ResetAppID()
		return nil
	case simulateledger.FieldUserID:
		m.ResetUserID()
		return nil
	case simulateledger.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case simulateledger.FieldIncoming:
		m.ResetIncoming()
		return nil
	case simulateledger.FieldOutcoming:
		m.ResetOutcoming()
		return nil
	}
	return fmt.Errorf("unknown SimulateLedger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SimulateLedgerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SimulateLedgerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SimulateLedgerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SimulateLedgerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SimulateLedgerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SimulateLedgerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SimulateLedgerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SimulateLedger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SimulateLedgerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SimulateLedger edge %s", name)
}

// SimulateProfitMutation represents an operation that mutates the SimulateProfit nodes in the graph.
type SimulateProfitMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	incoming      *decimal.Decimal
	addincoming   *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SimulateProfit, error)
	predicates    []predicate.SimulateProfit
}

var _ ent.Mutation = (*SimulateProfitMutation)(nil)

// simulateprofitOption allows management of the mutation configuration using functional options.
type simulateprofitOption func(*SimulateProfitMutation)

// newSimulateProfitMutation creates new mutation for the SimulateProfit entity.
func newSimulateProfitMutation(c config, op Op, opts ...simulateprofitOption) *SimulateProfitMutation {
	m := &SimulateProfitMutation{
		config:        c,
		op:            op,
		typ:           TypeSimulateProfit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSimulateProfitID sets the ID field of the mutation.
func withSimulateProfitID(id uint32) simulateprofitOption {
	return func(m *SimulateProfitMutation) {
		var (
			err   error
			once  sync.Once
			value *SimulateProfit
		)
		m.oldValue = func(ctx context.Context) (*SimulateProfit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SimulateProfit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSimulateProfit sets the old SimulateProfit of the mutation.
func withSimulateProfit(node *SimulateProfit) simulateprofitOption {
	return func(m *SimulateProfitMutation) {
		m.oldValue = func(context.Context) (*SimulateProfit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SimulateProfitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SimulateProfitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SimulateProfit entities.
func (m *SimulateProfitMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SimulateProfitMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SimulateProfitMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SimulateProfit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SimulateProfitMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SimulateProfitMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SimulateProfitMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SimulateProfitMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SimulateProfitMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SimulateProfitMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SimulateProfitMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SimulateProfitMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SimulateProfitMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SimulateProfitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SimulateProfitMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SimulateProfitMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SimulateProfitMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SimulateProfitMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SimulateProfitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *SimulateProfitMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SimulateProfitMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SimulateProfitMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SimulateProfitMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SimulateProfitMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SimulateProfitMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[simulateprofit.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SimulateProfitMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[simulateprofit.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SimulateProfitMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, simulateprofit.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *SimulateProfitMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SimulateProfitMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SimulateProfitMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[simulateprofit.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SimulateProfitMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[simulateprofit.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SimulateProfitMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, simulateprofit.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *SimulateProfitMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *SimulateProfitMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *SimulateProfitMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[simulateprofit.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *SimulateProfitMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[simulateprofit.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *SimulateProfitMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, simulateprofit.FieldCoinTypeID)
}

// SetIncoming sets the "incoming" field.
func (m *SimulateProfitMutation) SetIncoming(d decimal.Decimal) {
	m.incoming = &d
	m.addincoming = nil
}

// Incoming returns the value of the "incoming" field in the mutation.
func (m *SimulateProfitMutation) Incoming() (r decimal.Decimal, exists bool) {
	v := m.incoming
	if v == nil {
		return
	}
	return *v, true
}

// OldIncoming returns the old "incoming" field's value of the SimulateProfit entity.
// If the SimulateProfit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateProfitMutation) OldIncoming(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncoming is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncoming requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncoming: %w", err)
	}
	return oldValue.Incoming, nil
}

// AddIncoming adds d to the "incoming" field.
func (m *SimulateProfitMutation) AddIncoming(d decimal.Decimal) {
	if m.addincoming != nil {
		*m.addincoming = m.addincoming.Add(d)
	} else {
		m.addincoming = &d
	}
}

// AddedIncoming returns the value that was added to the "incoming" field in this mutation.
func (m *SimulateProfitMutation) AddedIncoming() (r decimal.Decimal, exists bool) {
	v := m.addincoming
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncoming clears the value of the "incoming" field.
func (m *SimulateProfitMutation) ClearIncoming() {
	m.incoming = nil
	m.addincoming = nil
	m.clearedFields[simulateprofit.FieldIncoming] = struct{}{}
}

// IncomingCleared returns if the "incoming" field was cleared in this mutation.
func (m *SimulateProfitMutation) IncomingCleared() bool {
	_, ok := m.clearedFields[simulateprofit.FieldIncoming]
	return ok
}

// ResetIncoming resets all changes to the "incoming" field.
func (m *SimulateProfitMutation) ResetIncoming() {
	m.incoming = nil
	m.addincoming = nil
	delete(m.clearedFields, simulateprofit.FieldIncoming)
}

// Where appends a list predicates to the SimulateProfitMutation builder.
func (m *SimulateProfitMutation) Where(ps ...predicate.SimulateProfit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SimulateProfitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SimulateProfit).
func (m *SimulateProfitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SimulateProfitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, simulateprofit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, simulateprofit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, simulateprofit.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, simulateprofit.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, simulateprofit.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, simulateprofit.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, simulateprofit.FieldCoinTypeID)
	}
	if m.incoming != nil {
		fields = append(fields, simulateprofit.FieldIncoming)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SimulateProfitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case simulateprofit.FieldCreatedAt:
		return m.CreatedAt()
	case simulateprofit.FieldUpdatedAt:
		return m.UpdatedAt()
	case simulateprofit.FieldDeletedAt:
		return m.DeletedAt()
	case simulateprofit.FieldEntID:
		return m.EntID()
	case simulateprofit.FieldAppID:
		return m.AppID()
	case simulateprofit.FieldUserID:
		return m.UserID()
	case simulateprofit.FieldCoinTypeID:
		return m.CoinTypeID()
	case simulateprofit.FieldIncoming:
		return m.Incoming()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SimulateProfitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case simulateprofit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case simulateprofit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case simulateprofit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case simulateprofit.FieldEntID:
		return m.OldEntID(ctx)
	case simulateprofit.FieldAppID:
		return m.OldAppID(ctx)
	case simulateprofit.FieldUserID:
		return m.OldUserID(ctx)
	case simulateprofit.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case simulateprofit.FieldIncoming:
		return m.OldIncoming(ctx)
	}
	return nil, fmt.Errorf("unknown SimulateProfit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateProfitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case simulateprofit.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case simulateprofit.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case simulateprofit.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case simulateprofit.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case simulateprofit.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case simulateprofit.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case simulateprofit.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case simulateprofit.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncoming(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateProfit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SimulateProfitMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, simulateprofit.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, simulateprofit.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, simulateprofit.FieldDeletedAt)
	}
	if m.addincoming != nil {
		fields = append(fields, simulateprofit.FieldIncoming)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SimulateProfitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case simulateprofit.FieldCreatedAt:
		return m.AddedCreatedAt()
	case simulateprofit.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case simulateprofit.FieldDeletedAt:
		return m.AddedDeletedAt()
	case simulateprofit.FieldIncoming:
		return m.AddedIncoming()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateProfitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case simulateprofit.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case simulateprofit.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case simulateprofit.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case simulateprofit.FieldIncoming:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncoming(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateProfit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SimulateProfitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(simulateprofit.FieldAppID) {
		fields = append(fields, simulateprofit.FieldAppID)
	}
	if m.FieldCleared(simulateprofit.FieldUserID) {
		fields = append(fields, simulateprofit.FieldUserID)
	}
	if m.FieldCleared(simulateprofit.FieldCoinTypeID) {
		fields = append(fields, simulateprofit.FieldCoinTypeID)
	}
	if m.FieldCleared(simulateprofit.FieldIncoming) {
		fields = append(fields, simulateprofit.FieldIncoming)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SimulateProfitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SimulateProfitMutation) ClearField(name string) error {
	switch name {
	case simulateprofit.FieldAppID:
		m.ClearAppID()
		return nil
	case simulateprofit.FieldUserID:
		m.ClearUserID()
		return nil
	case simulateprofit.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case simulateprofit.FieldIncoming:
		m.ClearIncoming()
		return nil
	}
	return fmt.Errorf("unknown SimulateProfit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SimulateProfitMutation) ResetField(name string) error {
	switch name {
	case simulateprofit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case simulateprofit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case simulateprofit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case simulateprofit.FieldEntID:
		m.ResetEntID()
		return nil
	case simulateprofit.FieldAppID:
		m.ResetAppID()
		return nil
	case simulateprofit.FieldUserID:
		m.ResetUserID()
		return nil
	case simulateprofit.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case simulateprofit.FieldIncoming:
		m.ResetIncoming()
		return nil
	}
	return fmt.Errorf("unknown SimulateProfit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SimulateProfitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SimulateProfitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SimulateProfitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SimulateProfitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SimulateProfitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SimulateProfitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SimulateProfitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SimulateProfit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SimulateProfitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SimulateProfit edge %s", name)
}

// SimulateStatementMutation represents an operation that mutates the SimulateStatement nodes in the graph.
type SimulateStatementMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	io_type       *string
	io_sub_type   *string
	amount        *decimal.Decimal
	addamount     *decimal.Decimal
	io_extra      *string
	send_coupon   *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SimulateStatement, error)
	predicates    []predicate.SimulateStatement
}

var _ ent.Mutation = (*SimulateStatementMutation)(nil)

// simulatestatementOption allows management of the mutation configuration using functional options.
type simulatestatementOption func(*SimulateStatementMutation)

// newSimulateStatementMutation creates new mutation for the SimulateStatement entity.
func newSimulateStatementMutation(c config, op Op, opts ...simulatestatementOption) *SimulateStatementMutation {
	m := &SimulateStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeSimulateStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSimulateStatementID sets the ID field of the mutation.
func withSimulateStatementID(id uint32) simulatestatementOption {
	return func(m *SimulateStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *SimulateStatement
		)
		m.oldValue = func(ctx context.Context) (*SimulateStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SimulateStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSimulateStatement sets the old SimulateStatement of the mutation.
func withSimulateStatement(node *SimulateStatement) simulatestatementOption {
	return func(m *SimulateStatementMutation) {
		m.oldValue = func(context.Context) (*SimulateStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SimulateStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SimulateStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SimulateStatement entities.
func (m *SimulateStatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SimulateStatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SimulateStatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SimulateStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SimulateStatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SimulateStatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SimulateStatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SimulateStatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SimulateStatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SimulateStatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SimulateStatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SimulateStatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SimulateStatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SimulateStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SimulateStatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SimulateStatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SimulateStatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SimulateStatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SimulateStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *SimulateStatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SimulateStatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SimulateStatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SimulateStatementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SimulateStatementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SimulateStatementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[simulatestatement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SimulateStatementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SimulateStatementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, simulatestatement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *SimulateStatementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SimulateStatementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SimulateStatementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[simulatestatement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SimulateStatementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SimulateStatementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, simulatestatement.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *SimulateStatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *SimulateStatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *SimulateStatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[simulatestatement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *SimulateStatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *SimulateStatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, simulatestatement.FieldCoinTypeID)
}

// SetIoType sets the "io_type" field.
func (m *SimulateStatementMutation) SetIoType(s string) {
	m.io_type = &s
}

// IoType returns the value of the "io_type" field in the mutation.
func (m *SimulateStatementMutation) IoType() (r string, exists bool) {
	v := m.io_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIoType returns the old "io_type" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldIoType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoType: %w", err)
	}
	return oldValue.IoType, nil
}

// ClearIoType clears the value of the "io_type" field.
func (m *SimulateStatementMutation) ClearIoType() {
	m.io_type = nil
	m.clearedFields[simulatestatement.FieldIoType] = struct{}{}
}

// IoTypeCleared returns if the "io_type" field was cleared in this mutation.
func (m *SimulateStatementMutation) IoTypeCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldIoType]
	return ok
}

// ResetIoType resets all changes to the "io_type" field.
func (m *SimulateStatementMutation) ResetIoType() {
	m.io_type = nil
	delete(m.clearedFields, simulatestatement.FieldIoType)
}

// SetIoSubType sets the "io_sub_type" field.
func (m *SimulateStatementMutation) SetIoSubType(s string) {
	m.io_sub_type = &s
}

// IoSubType returns the value of the "io_sub_type" field in the mutation.
func (m *SimulateStatementMutation) IoSubType() (r string, exists bool) {
	v := m.io_sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIoSubType returns the old "io_sub_type" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldIoSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoSubType: %w", err)
	}
	return oldValue.IoSubType, nil
}

// ClearIoSubType clears the value of the "io_sub_type" field.
func (m *SimulateStatementMutation) ClearIoSubType() {
	m.io_sub_type = nil
	m.clearedFields[simulatestatement.FieldIoSubType] = struct{}{}
}

// IoSubTypeCleared returns if the "io_sub_type" field was cleared in this mutation.
func (m *SimulateStatementMutation) IoSubTypeCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldIoSubType]
	return ok
}

// ResetIoSubType resets all changes to the "io_sub_type" field.
func (m *SimulateStatementMutation) ResetIoSubType() {
	m.io_sub_type = nil
	delete(m.clearedFields, simulatestatement.FieldIoSubType)
}

// SetAmount sets the "amount" field.
func (m *SimulateStatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *SimulateStatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *SimulateStatementMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *SimulateStatementMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *SimulateStatementMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[simulatestatement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *SimulateStatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *SimulateStatementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, simulatestatement.FieldAmount)
}

// SetIoExtra sets the "io_extra" field.
func (m *SimulateStatementMutation) SetIoExtra(s string) {
	m.io_extra = &s
}

// IoExtra returns the value of the "io_extra" field in the mutation.
func (m *SimulateStatementMutation) IoExtra() (r string, exists bool) {
	v := m.io_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldIoExtra returns the old "io_extra" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldIoExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoExtra: %w", err)
	}
	return oldValue.IoExtra, nil
}

// ClearIoExtra clears the value of the "io_extra" field.
func (m *SimulateStatementMutation) ClearIoExtra() {
	m.io_extra = nil
	m.clearedFields[simulatestatement.FieldIoExtra] = struct{}{}
}

// IoExtraCleared returns if the "io_extra" field was cleared in this mutation.
func (m *SimulateStatementMutation) IoExtraCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldIoExtra]
	return ok
}

// ResetIoExtra resets all changes to the "io_extra" field.
func (m *SimulateStatementMutation) ResetIoExtra() {
	m.io_extra = nil
	delete(m.clearedFields, simulatestatement.FieldIoExtra)
}

// SetSendCoupon sets the "send_coupon" field.
func (m *SimulateStatementMutation) SetSendCoupon(b bool) {
	m.send_coupon = &b
}

// SendCoupon returns the value of the "send_coupon" field in the mutation.
func (m *SimulateStatementMutation) SendCoupon() (r bool, exists bool) {
	v := m.send_coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldSendCoupon returns the old "send_coupon" field's value of the SimulateStatement entity.
// If the SimulateStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SimulateStatementMutation) OldSendCoupon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendCoupon: %w", err)
	}
	return oldValue.SendCoupon, nil
}

// ClearSendCoupon clears the value of the "send_coupon" field.
func (m *SimulateStatementMutation) ClearSendCoupon() {
	m.send_coupon = nil
	m.clearedFields[simulatestatement.FieldSendCoupon] = struct{}{}
}

// SendCouponCleared returns if the "send_coupon" field was cleared in this mutation.
func (m *SimulateStatementMutation) SendCouponCleared() bool {
	_, ok := m.clearedFields[simulatestatement.FieldSendCoupon]
	return ok
}

// ResetSendCoupon resets all changes to the "send_coupon" field.
func (m *SimulateStatementMutation) ResetSendCoupon() {
	m.send_coupon = nil
	delete(m.clearedFields, simulatestatement.FieldSendCoupon)
}

// Where appends a list predicates to the SimulateStatementMutation builder.
func (m *SimulateStatementMutation) Where(ps ...predicate.SimulateStatement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SimulateStatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SimulateStatement).
func (m *SimulateStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SimulateStatementMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, simulatestatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, simulatestatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, simulatestatement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, simulatestatement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, simulatestatement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, simulatestatement.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, simulatestatement.FieldCoinTypeID)
	}
	if m.io_type != nil {
		fields = append(fields, simulatestatement.FieldIoType)
	}
	if m.io_sub_type != nil {
		fields = append(fields, simulatestatement.FieldIoSubType)
	}
	if m.amount != nil {
		fields = append(fields, simulatestatement.FieldAmount)
	}
	if m.io_extra != nil {
		fields = append(fields, simulatestatement.FieldIoExtra)
	}
	if m.send_coupon != nil {
		fields = append(fields, simulatestatement.FieldSendCoupon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SimulateStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case simulatestatement.FieldCreatedAt:
		return m.CreatedAt()
	case simulatestatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case simulatestatement.FieldDeletedAt:
		return m.DeletedAt()
	case simulatestatement.FieldEntID:
		return m.EntID()
	case simulatestatement.FieldAppID:
		return m.AppID()
	case simulatestatement.FieldUserID:
		return m.UserID()
	case simulatestatement.FieldCoinTypeID:
		return m.CoinTypeID()
	case simulatestatement.FieldIoType:
		return m.IoType()
	case simulatestatement.FieldIoSubType:
		return m.IoSubType()
	case simulatestatement.FieldAmount:
		return m.Amount()
	case simulatestatement.FieldIoExtra:
		return m.IoExtra()
	case simulatestatement.FieldSendCoupon:
		return m.SendCoupon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SimulateStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case simulatestatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case simulatestatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case simulatestatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case simulatestatement.FieldEntID:
		return m.OldEntID(ctx)
	case simulatestatement.FieldAppID:
		return m.OldAppID(ctx)
	case simulatestatement.FieldUserID:
		return m.OldUserID(ctx)
	case simulatestatement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case simulatestatement.FieldIoType:
		return m.OldIoType(ctx)
	case simulatestatement.FieldIoSubType:
		return m.OldIoSubType(ctx)
	case simulatestatement.FieldAmount:
		return m.OldAmount(ctx)
	case simulatestatement.FieldIoExtra:
		return m.OldIoExtra(ctx)
	case simulatestatement.FieldSendCoupon:
		return m.OldSendCoupon(ctx)
	}
	return nil, fmt.Errorf("unknown SimulateStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case simulatestatement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case simulatestatement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case simulatestatement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case simulatestatement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case simulatestatement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case simulatestatement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case simulatestatement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case simulatestatement.FieldIoType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoType(v)
		return nil
	case simulatestatement.FieldIoSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoSubType(v)
		return nil
	case simulatestatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case simulatestatement.FieldIoExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoExtra(v)
		return nil
	case simulatestatement.FieldSendCoupon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendCoupon(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SimulateStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, simulatestatement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, simulatestatement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, simulatestatement.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, simulatestatement.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SimulateStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case simulatestatement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case simulatestatement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case simulatestatement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case simulatestatement.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SimulateStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case simulatestatement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case simulatestatement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case simulatestatement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case simulatestatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown SimulateStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SimulateStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(simulatestatement.FieldAppID) {
		fields = append(fields, simulatestatement.FieldAppID)
	}
	if m.FieldCleared(simulatestatement.FieldUserID) {
		fields = append(fields, simulatestatement.FieldUserID)
	}
	if m.FieldCleared(simulatestatement.FieldCoinTypeID) {
		fields = append(fields, simulatestatement.FieldCoinTypeID)
	}
	if m.FieldCleared(simulatestatement.FieldIoType) {
		fields = append(fields, simulatestatement.FieldIoType)
	}
	if m.FieldCleared(simulatestatement.FieldIoSubType) {
		fields = append(fields, simulatestatement.FieldIoSubType)
	}
	if m.FieldCleared(simulatestatement.FieldAmount) {
		fields = append(fields, simulatestatement.FieldAmount)
	}
	if m.FieldCleared(simulatestatement.FieldIoExtra) {
		fields = append(fields, simulatestatement.FieldIoExtra)
	}
	if m.FieldCleared(simulatestatement.FieldSendCoupon) {
		fields = append(fields, simulatestatement.FieldSendCoupon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SimulateStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SimulateStatementMutation) ClearField(name string) error {
	switch name {
	case simulatestatement.FieldAppID:
		m.ClearAppID()
		return nil
	case simulatestatement.FieldUserID:
		m.ClearUserID()
		return nil
	case simulatestatement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case simulatestatement.FieldIoType:
		m.ClearIoType()
		return nil
	case simulatestatement.FieldIoSubType:
		m.ClearIoSubType()
		return nil
	case simulatestatement.FieldAmount:
		m.ClearAmount()
		return nil
	case simulatestatement.FieldIoExtra:
		m.ClearIoExtra()
		return nil
	case simulatestatement.FieldSendCoupon:
		m.ClearSendCoupon()
		return nil
	}
	return fmt.Errorf("unknown SimulateStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SimulateStatementMutation) ResetField(name string) error {
	switch name {
	case simulatestatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case simulatestatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case simulatestatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case simulatestatement.FieldEntID:
		m.ResetEntID()
		return nil
	case simulatestatement.FieldAppID:
		m.ResetAppID()
		return nil
	case simulatestatement.FieldUserID:
		m.ResetUserID()
		return nil
	case simulatestatement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case simulatestatement.FieldIoType:
		m.ResetIoType()
		return nil
	case simulatestatement.FieldIoSubType:
		m.ResetIoSubType()
		return nil
	case simulatestatement.FieldAmount:
		m.ResetAmount()
		return nil
	case simulatestatement.FieldIoExtra:
		m.ResetIoExtra()
		return nil
	case simulatestatement.FieldSendCoupon:
		m.ResetSendCoupon()
		return nil
	}
	return fmt.Errorf("unknown SimulateStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SimulateStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SimulateStatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SimulateStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SimulateStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SimulateStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SimulateStatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SimulateStatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SimulateStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SimulateStatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SimulateStatement edge %s", name)
}

// StatementMutation represents an operation that mutates the Statement nodes in the graph.
type StatementMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	io_type       *string
	io_sub_type   *string
	amount        *decimal.Decimal
	addamount     *decimal.Decimal
	io_extra      *string
	io_extra_v1   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Statement, error)
	predicates    []predicate.Statement
}

var _ ent.Mutation = (*StatementMutation)(nil)

// statementOption allows management of the mutation configuration using functional options.
type statementOption func(*StatementMutation)

// newStatementMutation creates new mutation for the Statement entity.
func newStatementMutation(c config, op Op, opts ...statementOption) *StatementMutation {
	m := &StatementMutation{
		config:        c,
		op:            op,
		typ:           TypeStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatementID sets the ID field of the mutation.
func withStatementID(id uint32) statementOption {
	return func(m *StatementMutation) {
		var (
			err   error
			once  sync.Once
			value *Statement
		)
		m.oldValue = func(ctx context.Context) (*Statement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatement sets the old Statement of the mutation.
func withStatement(node *Statement) statementOption {
	return func(m *StatementMutation) {
		m.oldValue = func(context.Context) (*Statement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statement entities.
func (m *StatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *StatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *StatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *StatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *StatementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *StatementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *StatementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[statement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *StatementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *StatementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, statement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *StatementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StatementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *StatementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[statement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *StatementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StatementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, statement.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *StatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *StatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *StatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[statement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *StatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *StatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, statement.FieldCoinTypeID)
}

// SetIoType sets the "io_type" field.
func (m *StatementMutation) SetIoType(s string) {
	m.io_type = &s
}

// IoType returns the value of the "io_type" field in the mutation.
func (m *StatementMutation) IoType() (r string, exists bool) {
	v := m.io_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIoType returns the old "io_type" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldIoType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoType: %w", err)
	}
	return oldValue.IoType, nil
}

// ClearIoType clears the value of the "io_type" field.
func (m *StatementMutation) ClearIoType() {
	m.io_type = nil
	m.clearedFields[statement.FieldIoType] = struct{}{}
}

// IoTypeCleared returns if the "io_type" field was cleared in this mutation.
func (m *StatementMutation) IoTypeCleared() bool {
	_, ok := m.clearedFields[statement.FieldIoType]
	return ok
}

// ResetIoType resets all changes to the "io_type" field.
func (m *StatementMutation) ResetIoType() {
	m.io_type = nil
	delete(m.clearedFields, statement.FieldIoType)
}

// SetIoSubType sets the "io_sub_type" field.
func (m *StatementMutation) SetIoSubType(s string) {
	m.io_sub_type = &s
}

// IoSubType returns the value of the "io_sub_type" field in the mutation.
func (m *StatementMutation) IoSubType() (r string, exists bool) {
	v := m.io_sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIoSubType returns the old "io_sub_type" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldIoSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoSubType: %w", err)
	}
	return oldValue.IoSubType, nil
}

// ClearIoSubType clears the value of the "io_sub_type" field.
func (m *StatementMutation) ClearIoSubType() {
	m.io_sub_type = nil
	m.clearedFields[statement.FieldIoSubType] = struct{}{}
}

// IoSubTypeCleared returns if the "io_sub_type" field was cleared in this mutation.
func (m *StatementMutation) IoSubTypeCleared() bool {
	_, ok := m.clearedFields[statement.FieldIoSubType]
	return ok
}

// ResetIoSubType resets all changes to the "io_sub_type" field.
func (m *StatementMutation) ResetIoSubType() {
	m.io_sub_type = nil
	delete(m.clearedFields, statement.FieldIoSubType)
}

// SetAmount sets the "amount" field.
func (m *StatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *StatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *StatementMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *StatementMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *StatementMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[statement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *StatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[statement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *StatementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, statement.FieldAmount)
}

// SetIoExtra sets the "io_extra" field.
func (m *StatementMutation) SetIoExtra(s string) {
	m.io_extra = &s
}

// IoExtra returns the value of the "io_extra" field in the mutation.
func (m *StatementMutation) IoExtra() (r string, exists bool) {
	v := m.io_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldIoExtra returns the old "io_extra" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldIoExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoExtra: %w", err)
	}
	return oldValue.IoExtra, nil
}

// ClearIoExtra clears the value of the "io_extra" field.
func (m *StatementMutation) ClearIoExtra() {
	m.io_extra = nil
	m.clearedFields[statement.FieldIoExtra] = struct{}{}
}

// IoExtraCleared returns if the "io_extra" field was cleared in this mutation.
func (m *StatementMutation) IoExtraCleared() bool {
	_, ok := m.clearedFields[statement.FieldIoExtra]
	return ok
}

// ResetIoExtra resets all changes to the "io_extra" field.
func (m *StatementMutation) ResetIoExtra() {
	m.io_extra = nil
	delete(m.clearedFields, statement.FieldIoExtra)
}

// SetIoExtraV1 sets the "io_extra_v1" field.
func (m *StatementMutation) SetIoExtraV1(s string) {
	m.io_extra_v1 = &s
}

// IoExtraV1 returns the value of the "io_extra_v1" field in the mutation.
func (m *StatementMutation) IoExtraV1() (r string, exists bool) {
	v := m.io_extra_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldIoExtraV1 returns the old "io_extra_v1" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldIoExtraV1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoExtraV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoExtraV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoExtraV1: %w", err)
	}
	return oldValue.IoExtraV1, nil
}

// ClearIoExtraV1 clears the value of the "io_extra_v1" field.
func (m *StatementMutation) ClearIoExtraV1() {
	m.io_extra_v1 = nil
	m.clearedFields[statement.FieldIoExtraV1] = struct{}{}
}

// IoExtraV1Cleared returns if the "io_extra_v1" field was cleared in this mutation.
func (m *StatementMutation) IoExtraV1Cleared() bool {
	_, ok := m.clearedFields[statement.FieldIoExtraV1]
	return ok
}

// ResetIoExtraV1 resets all changes to the "io_extra_v1" field.
func (m *StatementMutation) ResetIoExtraV1() {
	m.io_extra_v1 = nil
	delete(m.clearedFields, statement.FieldIoExtraV1)
}

// Where appends a list predicates to the StatementMutation builder.
func (m *StatementMutation) Where(ps ...predicate.Statement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statement).
func (m *StatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatementMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, statement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, statement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, statement.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.io_type != nil {
		fields = append(fields, statement.FieldIoType)
	}
	if m.io_sub_type != nil {
		fields = append(fields, statement.FieldIoSubType)
	}
	if m.amount != nil {
		fields = append(fields, statement.FieldAmount)
	}
	if m.io_extra != nil {
		fields = append(fields, statement.FieldIoExtra)
	}
	if m.io_extra_v1 != nil {
		fields = append(fields, statement.FieldIoExtraV1)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.CreatedAt()
	case statement.FieldUpdatedAt:
		return m.UpdatedAt()
	case statement.FieldDeletedAt:
		return m.DeletedAt()
	case statement.FieldEntID:
		return m.EntID()
	case statement.FieldAppID:
		return m.AppID()
	case statement.FieldUserID:
		return m.UserID()
	case statement.FieldCoinTypeID:
		return m.CoinTypeID()
	case statement.FieldIoType:
		return m.IoType()
	case statement.FieldIoSubType:
		return m.IoSubType()
	case statement.FieldAmount:
		return m.Amount()
	case statement.FieldIoExtra:
		return m.IoExtra()
	case statement.FieldIoExtraV1:
		return m.IoExtraV1()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case statement.FieldEntID:
		return m.OldEntID(ctx)
	case statement.FieldAppID:
		return m.OldAppID(ctx)
	case statement.FieldUserID:
		return m.OldUserID(ctx)
	case statement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case statement.FieldIoType:
		return m.OldIoType(ctx)
	case statement.FieldIoSubType:
		return m.OldIoSubType(ctx)
	case statement.FieldAmount:
		return m.OldAmount(ctx)
	case statement.FieldIoExtra:
		return m.OldIoExtra(ctx)
	case statement.FieldIoExtraV1:
		return m.OldIoExtraV1(ctx)
	}
	return nil, fmt.Errorf("unknown Statement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case statement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case statement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case statement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case statement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case statement.FieldIoType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoType(v)
		return nil
	case statement.FieldIoSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoSubType(v)
		return nil
	case statement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case statement.FieldIoExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoExtra(v)
		return nil
	case statement.FieldIoExtraV1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoExtraV1(v)
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, statement.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case statement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case statement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case statement.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case statement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Statement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statement.FieldAppID) {
		fields = append(fields, statement.FieldAppID)
	}
	if m.FieldCleared(statement.FieldUserID) {
		fields = append(fields, statement.FieldUserID)
	}
	if m.FieldCleared(statement.FieldCoinTypeID) {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.FieldCleared(statement.FieldIoType) {
		fields = append(fields, statement.FieldIoType)
	}
	if m.FieldCleared(statement.FieldIoSubType) {
		fields = append(fields, statement.FieldIoSubType)
	}
	if m.FieldCleared(statement.FieldAmount) {
		fields = append(fields, statement.FieldAmount)
	}
	if m.FieldCleared(statement.FieldIoExtra) {
		fields = append(fields, statement.FieldIoExtra)
	}
	if m.FieldCleared(statement.FieldIoExtraV1) {
		fields = append(fields, statement.FieldIoExtraV1)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatementMutation) ClearField(name string) error {
	switch name {
	case statement.FieldAppID:
		m.ClearAppID()
		return nil
	case statement.FieldUserID:
		m.ClearUserID()
		return nil
	case statement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case statement.FieldIoType:
		m.ClearIoType()
		return nil
	case statement.FieldIoSubType:
		m.ClearIoSubType()
		return nil
	case statement.FieldAmount:
		m.ClearAmount()
		return nil
	case statement.FieldIoExtra:
		m.ClearIoExtra()
		return nil
	case statement.FieldIoExtraV1:
		m.ClearIoExtraV1()
		return nil
	}
	return fmt.Errorf("unknown Statement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatementMutation) ResetField(name string) error {
	switch name {
	case statement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case statement.FieldEntID:
		m.ResetEntID()
		return nil
	case statement.FieldAppID:
		m.ResetAppID()
		return nil
	case statement.FieldUserID:
		m.ResetUserID()
		return nil
	case statement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case statement.FieldIoType:
		m.ResetIoType()
		return nil
	case statement.FieldIoSubType:
		m.ResetIoSubType()
		return nil
	case statement.FieldAmount:
		m.ResetAmount()
		return nil
	case statement.FieldIoExtra:
		m.ResetIoExtra()
		return nil
	case statement.FieldIoExtraV1:
		m.ResetIoExtraV1()
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Statement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Statement edge %s", name)
}

// UnsoldStatementMutation represents an operation that mutates the UnsoldStatement nodes in the graph.
type UnsoldStatementMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	good_id         *uuid.UUID
	coin_type_id    *uuid.UUID
	amount          *decimal.Decimal
	addamount       *decimal.Decimal
	benefit_date    *uint32
	addbenefit_date *int32
	statement_id    *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UnsoldStatement, error)
	predicates      []predicate.UnsoldStatement
}

var _ ent.Mutation = (*UnsoldStatementMutation)(nil)

// unsoldstatementOption allows management of the mutation configuration using functional options.
type unsoldstatementOption func(*UnsoldStatementMutation)

// newUnsoldStatementMutation creates new mutation for the UnsoldStatement entity.
func newUnsoldStatementMutation(c config, op Op, opts ...unsoldstatementOption) *UnsoldStatementMutation {
	m := &UnsoldStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeUnsoldStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnsoldStatementID sets the ID field of the mutation.
func withUnsoldStatementID(id uint32) unsoldstatementOption {
	return func(m *UnsoldStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *UnsoldStatement
		)
		m.oldValue = func(ctx context.Context) (*UnsoldStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UnsoldStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnsoldStatement sets the old UnsoldStatement of the mutation.
func withUnsoldStatement(node *UnsoldStatement) unsoldstatementOption {
	return func(m *UnsoldStatementMutation) {
		m.oldValue = func(context.Context) (*UnsoldStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnsoldStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnsoldStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UnsoldStatement entities.
func (m *UnsoldStatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnsoldStatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UnsoldStatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UnsoldStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UnsoldStatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UnsoldStatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *UnsoldStatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UnsoldStatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UnsoldStatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UnsoldStatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UnsoldStatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *UnsoldStatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UnsoldStatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UnsoldStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UnsoldStatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UnsoldStatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *UnsoldStatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UnsoldStatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UnsoldStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *UnsoldStatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UnsoldStatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UnsoldStatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *UnsoldStatementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *UnsoldStatementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *UnsoldStatementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[unsoldstatement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *UnsoldStatementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[unsoldstatement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *UnsoldStatementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, unsoldstatement.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *UnsoldStatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *UnsoldStatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *UnsoldStatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[unsoldstatement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *UnsoldStatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[unsoldstatement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *UnsoldStatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, unsoldstatement.FieldCoinTypeID)
}

// SetAmount sets the "amount" field.
func (m *UnsoldStatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *UnsoldStatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *UnsoldStatementMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *UnsoldStatementMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *UnsoldStatementMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[unsoldstatement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *UnsoldStatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[unsoldstatement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *UnsoldStatementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, unsoldstatement.FieldAmount)
}

// SetBenefitDate sets the "benefit_date" field.
func (m *UnsoldStatementMutation) SetBenefitDate(u uint32) {
	m.benefit_date = &u
	m.addbenefit_date = nil
}

// BenefitDate returns the value of the "benefit_date" field in the mutation.
func (m *UnsoldStatementMutation) BenefitDate() (r uint32, exists bool) {
	v := m.benefit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitDate returns the old "benefit_date" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldBenefitDate(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitDate: %w", err)
	}
	return oldValue.BenefitDate, nil
}

// AddBenefitDate adds u to the "benefit_date" field.
func (m *UnsoldStatementMutation) AddBenefitDate(u int32) {
	if m.addbenefit_date != nil {
		*m.addbenefit_date += u
	} else {
		m.addbenefit_date = &u
	}
}

// AddedBenefitDate returns the value that was added to the "benefit_date" field in this mutation.
func (m *UnsoldStatementMutation) AddedBenefitDate() (r int32, exists bool) {
	v := m.addbenefit_date
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitDate clears the value of the "benefit_date" field.
func (m *UnsoldStatementMutation) ClearBenefitDate() {
	m.benefit_date = nil
	m.addbenefit_date = nil
	m.clearedFields[unsoldstatement.FieldBenefitDate] = struct{}{}
}

// BenefitDateCleared returns if the "benefit_date" field was cleared in this mutation.
func (m *UnsoldStatementMutation) BenefitDateCleared() bool {
	_, ok := m.clearedFields[unsoldstatement.FieldBenefitDate]
	return ok
}

// ResetBenefitDate resets all changes to the "benefit_date" field.
func (m *UnsoldStatementMutation) ResetBenefitDate() {
	m.benefit_date = nil
	m.addbenefit_date = nil
	delete(m.clearedFields, unsoldstatement.FieldBenefitDate)
}

// SetStatementID sets the "statement_id" field.
func (m *UnsoldStatementMutation) SetStatementID(u uuid.UUID) {
	m.statement_id = &u
}

// StatementID returns the value of the "statement_id" field in the mutation.
func (m *UnsoldStatementMutation) StatementID() (r uuid.UUID, exists bool) {
	v := m.statement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementID returns the old "statement_id" field's value of the UnsoldStatement entity.
// If the UnsoldStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnsoldStatementMutation) OldStatementID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementID: %w", err)
	}
	return oldValue.StatementID, nil
}

// ClearStatementID clears the value of the "statement_id" field.
func (m *UnsoldStatementMutation) ClearStatementID() {
	m.statement_id = nil
	m.clearedFields[unsoldstatement.FieldStatementID] = struct{}{}
}

// StatementIDCleared returns if the "statement_id" field was cleared in this mutation.
func (m *UnsoldStatementMutation) StatementIDCleared() bool {
	_, ok := m.clearedFields[unsoldstatement.FieldStatementID]
	return ok
}

// ResetStatementID resets all changes to the "statement_id" field.
func (m *UnsoldStatementMutation) ResetStatementID() {
	m.statement_id = nil
	delete(m.clearedFields, unsoldstatement.FieldStatementID)
}

// Where appends a list predicates to the UnsoldStatementMutation builder.
func (m *UnsoldStatementMutation) Where(ps ...predicate.UnsoldStatement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UnsoldStatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UnsoldStatement).
func (m *UnsoldStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnsoldStatementMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, unsoldstatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, unsoldstatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, unsoldstatement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, unsoldstatement.FieldEntID)
	}
	if m.good_id != nil {
		fields = append(fields, unsoldstatement.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, unsoldstatement.FieldCoinTypeID)
	}
	if m.amount != nil {
		fields = append(fields, unsoldstatement.FieldAmount)
	}
	if m.benefit_date != nil {
		fields = append(fields, unsoldstatement.FieldBenefitDate)
	}
	if m.statement_id != nil {
		fields = append(fields, unsoldstatement.FieldStatementID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnsoldStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		return m.CreatedAt()
	case unsoldstatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case unsoldstatement.FieldDeletedAt:
		return m.DeletedAt()
	case unsoldstatement.FieldEntID:
		return m.EntID()
	case unsoldstatement.FieldGoodID:
		return m.GoodID()
	case unsoldstatement.FieldCoinTypeID:
		return m.CoinTypeID()
	case unsoldstatement.FieldAmount:
		return m.Amount()
	case unsoldstatement.FieldBenefitDate:
		return m.BenefitDate()
	case unsoldstatement.FieldStatementID:
		return m.StatementID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnsoldStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case unsoldstatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case unsoldstatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case unsoldstatement.FieldEntID:
		return m.OldEntID(ctx)
	case unsoldstatement.FieldGoodID:
		return m.OldGoodID(ctx)
	case unsoldstatement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case unsoldstatement.FieldAmount:
		return m.OldAmount(ctx)
	case unsoldstatement.FieldBenefitDate:
		return m.OldBenefitDate(ctx)
	case unsoldstatement.FieldStatementID:
		return m.OldStatementID(ctx)
	}
	return nil, fmt.Errorf("unknown UnsoldStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnsoldStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case unsoldstatement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case unsoldstatement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case unsoldstatement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case unsoldstatement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case unsoldstatement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case unsoldstatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case unsoldstatement.FieldBenefitDate:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitDate(v)
		return nil
	case unsoldstatement.FieldStatementID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementID(v)
		return nil
	}
	return fmt.Errorf("unknown UnsoldStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnsoldStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, unsoldstatement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, unsoldstatement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, unsoldstatement.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, unsoldstatement.FieldAmount)
	}
	if m.addbenefit_date != nil {
		fields = append(fields, unsoldstatement.FieldBenefitDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnsoldStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case unsoldstatement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case unsoldstatement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case unsoldstatement.FieldAmount:
		return m.AddedAmount()
	case unsoldstatement.FieldBenefitDate:
		return m.AddedBenefitDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnsoldStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case unsoldstatement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case unsoldstatement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case unsoldstatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case unsoldstatement.FieldBenefitDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitDate(v)
		return nil
	}
	return fmt.Errorf("unknown UnsoldStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnsoldStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(unsoldstatement.FieldGoodID) {
		fields = append(fields, unsoldstatement.FieldGoodID)
	}
	if m.FieldCleared(unsoldstatement.FieldCoinTypeID) {
		fields = append(fields, unsoldstatement.FieldCoinTypeID)
	}
	if m.FieldCleared(unsoldstatement.FieldAmount) {
		fields = append(fields, unsoldstatement.FieldAmount)
	}
	if m.FieldCleared(unsoldstatement.FieldBenefitDate) {
		fields = append(fields, unsoldstatement.FieldBenefitDate)
	}
	if m.FieldCleared(unsoldstatement.FieldStatementID) {
		fields = append(fields, unsoldstatement.FieldStatementID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnsoldStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnsoldStatementMutation) ClearField(name string) error {
	switch name {
	case unsoldstatement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case unsoldstatement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case unsoldstatement.FieldAmount:
		m.ClearAmount()
		return nil
	case unsoldstatement.FieldBenefitDate:
		m.ClearBenefitDate()
		return nil
	case unsoldstatement.FieldStatementID:
		m.ClearStatementID()
		return nil
	}
	return fmt.Errorf("unknown UnsoldStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnsoldStatementMutation) ResetField(name string) error {
	switch name {
	case unsoldstatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case unsoldstatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case unsoldstatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case unsoldstatement.FieldEntID:
		m.ResetEntID()
		return nil
	case unsoldstatement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case unsoldstatement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case unsoldstatement.FieldAmount:
		m.ResetAmount()
		return nil
	case unsoldstatement.FieldBenefitDate:
		m.ResetBenefitDate()
		return nil
	case unsoldstatement.FieldStatementID:
		m.ResetStatementID()
		return nil
	}
	return fmt.Errorf("unknown UnsoldStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnsoldStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnsoldStatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnsoldStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnsoldStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnsoldStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnsoldStatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnsoldStatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UnsoldStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnsoldStatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UnsoldStatement edge %s", name)
}

// WithdrawMutation represents an operation that mutates the Withdraw nodes in the graph.
type WithdrawMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint32
	created_at              *uint32
	addcreated_at           *int32
	updated_at              *uint32
	addupdated_at           *int32
	deleted_at              *uint32
	adddeleted_at           *int32
	ent_id                  *uuid.UUID
	app_id                  *uuid.UUID
	user_id                 *uuid.UUID
	coin_type_id            *uuid.UUID
	account_id              *uuid.UUID
	address                 *string
	platform_transaction_id *uuid.UUID
	chain_transaction_id    *string
	state                   *string
	amount                  *decimal.Decimal
	addamount               *decimal.Decimal
	review_id               *uuid.UUID
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Withdraw, error)
	predicates              []predicate.Withdraw
}

var _ ent.Mutation = (*WithdrawMutation)(nil)

// withdrawOption allows management of the mutation configuration using functional options.
type withdrawOption func(*WithdrawMutation)

// newWithdrawMutation creates new mutation for the Withdraw entity.
func newWithdrawMutation(c config, op Op, opts ...withdrawOption) *WithdrawMutation {
	m := &WithdrawMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdraw,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawID sets the ID field of the mutation.
func withWithdrawID(id uint32) withdrawOption {
	return func(m *WithdrawMutation) {
		var (
			err   error
			once  sync.Once
			value *Withdraw
		)
		m.oldValue = func(ctx context.Context) (*Withdraw, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Withdraw.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdraw sets the old Withdraw of the mutation.
func withWithdraw(node *Withdraw) withdrawOption {
	return func(m *WithdrawMutation) {
		m.oldValue = func(context.Context) (*Withdraw, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Withdraw entities.
func (m *WithdrawMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Withdraw.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *WithdrawMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WithdrawMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WithdrawMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WithdrawMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *WithdrawMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WithdrawMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WithdrawMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WithdrawMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WithdrawMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *WithdrawMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *WithdrawMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WithdrawMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *WithdrawMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *WithdrawMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *WithdrawMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *WithdrawMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *WithdrawMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *WithdrawMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[withdraw.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *WithdrawMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *WithdrawMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, withdraw.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *WithdrawMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WithdrawMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *WithdrawMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[withdraw.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *WithdrawMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WithdrawMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, withdraw.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *WithdrawMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *WithdrawMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *WithdrawMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[withdraw.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *WithdrawMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *WithdrawMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, withdraw.FieldCoinTypeID)
}

// SetAccountID sets the "account_id" field.
func (m *WithdrawMutation) SetAccountID(u uuid.UUID) {
	m.account_id = &u
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *WithdrawMutation) AccountID() (r uuid.UUID, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *WithdrawMutation) ClearAccountID() {
	m.account_id = nil
	m.clearedFields[withdraw.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *WithdrawMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *WithdrawMutation) ResetAccountID() {
	m.account_id = nil
	delete(m.clearedFields, withdraw.FieldAccountID)
}

// SetAddress sets the "address" field.
func (m *WithdrawMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *WithdrawMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *WithdrawMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[withdraw.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *WithdrawMutation) AddressCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *WithdrawMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, withdraw.FieldAddress)
}

// SetPlatformTransactionID sets the "platform_transaction_id" field.
func (m *WithdrawMutation) SetPlatformTransactionID(u uuid.UUID) {
	m.platform_transaction_id = &u
}

// PlatformTransactionID returns the value of the "platform_transaction_id" field in the mutation.
func (m *WithdrawMutation) PlatformTransactionID() (r uuid.UUID, exists bool) {
	v := m.platform_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformTransactionID returns the old "platform_transaction_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldPlatformTransactionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformTransactionID: %w", err)
	}
	return oldValue.PlatformTransactionID, nil
}

// ClearPlatformTransactionID clears the value of the "platform_transaction_id" field.
func (m *WithdrawMutation) ClearPlatformTransactionID() {
	m.platform_transaction_id = nil
	m.clearedFields[withdraw.FieldPlatformTransactionID] = struct{}{}
}

// PlatformTransactionIDCleared returns if the "platform_transaction_id" field was cleared in this mutation.
func (m *WithdrawMutation) PlatformTransactionIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldPlatformTransactionID]
	return ok
}

// ResetPlatformTransactionID resets all changes to the "platform_transaction_id" field.
func (m *WithdrawMutation) ResetPlatformTransactionID() {
	m.platform_transaction_id = nil
	delete(m.clearedFields, withdraw.FieldPlatformTransactionID)
}

// SetChainTransactionID sets the "chain_transaction_id" field.
func (m *WithdrawMutation) SetChainTransactionID(s string) {
	m.chain_transaction_id = &s
}

// ChainTransactionID returns the value of the "chain_transaction_id" field in the mutation.
func (m *WithdrawMutation) ChainTransactionID() (r string, exists bool) {
	v := m.chain_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainTransactionID returns the old "chain_transaction_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldChainTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainTransactionID: %w", err)
	}
	return oldValue.ChainTransactionID, nil
}

// ClearChainTransactionID clears the value of the "chain_transaction_id" field.
func (m *WithdrawMutation) ClearChainTransactionID() {
	m.chain_transaction_id = nil
	m.clearedFields[withdraw.FieldChainTransactionID] = struct{}{}
}

// ChainTransactionIDCleared returns if the "chain_transaction_id" field was cleared in this mutation.
func (m *WithdrawMutation) ChainTransactionIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldChainTransactionID]
	return ok
}

// ResetChainTransactionID resets all changes to the "chain_transaction_id" field.
func (m *WithdrawMutation) ResetChainTransactionID() {
	m.chain_transaction_id = nil
	delete(m.clearedFields, withdraw.FieldChainTransactionID)
}

// SetState sets the "state" field.
func (m *WithdrawMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WithdrawMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *WithdrawMutation) ClearState() {
	m.state = nil
	m.clearedFields[withdraw.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *WithdrawMutation) StateCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *WithdrawMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, withdraw.FieldState)
}

// SetAmount sets the "amount" field.
func (m *WithdrawMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WithdrawMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *WithdrawMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WithdrawMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *WithdrawMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[withdraw.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *WithdrawMutation) AmountCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *WithdrawMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, withdraw.FieldAmount)
}

// SetReviewID sets the "review_id" field.
func (m *WithdrawMutation) SetReviewID(u uuid.UUID) {
	m.review_id = &u
}

// ReviewID returns the value of the "review_id" field in the mutation.
func (m *WithdrawMutation) ReviewID() (r uuid.UUID, exists bool) {
	v := m.review_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewID returns the old "review_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldReviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewID: %w", err)
	}
	return oldValue.ReviewID, nil
}

// ClearReviewID clears the value of the "review_id" field.
func (m *WithdrawMutation) ClearReviewID() {
	m.review_id = nil
	m.clearedFields[withdraw.FieldReviewID] = struct{}{}
}

// ReviewIDCleared returns if the "review_id" field was cleared in this mutation.
func (m *WithdrawMutation) ReviewIDCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldReviewID]
	return ok
}

// ResetReviewID resets all changes to the "review_id" field.
func (m *WithdrawMutation) ResetReviewID() {
	m.review_id = nil
	delete(m.clearedFields, withdraw.FieldReviewID)
}

// Where appends a list predicates to the WithdrawMutation builder.
func (m *WithdrawMutation) Where(ps ...predicate.Withdraw) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WithdrawMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Withdraw).
func (m *WithdrawMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, withdraw.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, withdraw.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, withdraw.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, withdraw.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, withdraw.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, withdraw.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, withdraw.FieldCoinTypeID)
	}
	if m.account_id != nil {
		fields = append(fields, withdraw.FieldAccountID)
	}
	if m.address != nil {
		fields = append(fields, withdraw.FieldAddress)
	}
	if m.platform_transaction_id != nil {
		fields = append(fields, withdraw.FieldPlatformTransactionID)
	}
	if m.chain_transaction_id != nil {
		fields = append(fields, withdraw.FieldChainTransactionID)
	}
	if m.state != nil {
		fields = append(fields, withdraw.FieldState)
	}
	if m.amount != nil {
		fields = append(fields, withdraw.FieldAmount)
	}
	if m.review_id != nil {
		fields = append(fields, withdraw.FieldReviewID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdraw.FieldCreatedAt:
		return m.CreatedAt()
	case withdraw.FieldUpdatedAt:
		return m.UpdatedAt()
	case withdraw.FieldDeletedAt:
		return m.DeletedAt()
	case withdraw.FieldEntID:
		return m.EntID()
	case withdraw.FieldAppID:
		return m.AppID()
	case withdraw.FieldUserID:
		return m.UserID()
	case withdraw.FieldCoinTypeID:
		return m.CoinTypeID()
	case withdraw.FieldAccountID:
		return m.AccountID()
	case withdraw.FieldAddress:
		return m.Address()
	case withdraw.FieldPlatformTransactionID:
		return m.PlatformTransactionID()
	case withdraw.FieldChainTransactionID:
		return m.ChainTransactionID()
	case withdraw.FieldState:
		return m.State()
	case withdraw.FieldAmount:
		return m.Amount()
	case withdraw.FieldReviewID:
		return m.ReviewID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdraw.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdraw.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case withdraw.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case withdraw.FieldEntID:
		return m.OldEntID(ctx)
	case withdraw.FieldAppID:
		return m.OldAppID(ctx)
	case withdraw.FieldUserID:
		return m.OldUserID(ctx)
	case withdraw.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case withdraw.FieldAccountID:
		return m.OldAccountID(ctx)
	case withdraw.FieldAddress:
		return m.OldAddress(ctx)
	case withdraw.FieldPlatformTransactionID:
		return m.OldPlatformTransactionID(ctx)
	case withdraw.FieldChainTransactionID:
		return m.OldChainTransactionID(ctx)
	case withdraw.FieldState:
		return m.OldState(ctx)
	case withdraw.FieldAmount:
		return m.OldAmount(ctx)
	case withdraw.FieldReviewID:
		return m.OldReviewID(ctx)
	}
	return nil, fmt.Errorf("unknown Withdraw field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdraw.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdraw.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case withdraw.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case withdraw.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case withdraw.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case withdraw.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case withdraw.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case withdraw.FieldAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case withdraw.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case withdraw.FieldPlatformTransactionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformTransactionID(v)
		return nil
	case withdraw.FieldChainTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainTransactionID(v)
		return nil
	case withdraw.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case withdraw.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case withdraw.FieldReviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewID(v)
		return nil
	}
	return fmt.Errorf("unknown Withdraw field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, withdraw.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, withdraw.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, withdraw.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, withdraw.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdraw.FieldCreatedAt:
		return m.AddedCreatedAt()
	case withdraw.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case withdraw.FieldDeletedAt:
		return m.AddedDeletedAt()
	case withdraw.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdraw.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case withdraw.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case withdraw.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case withdraw.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Withdraw numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(withdraw.FieldAppID) {
		fields = append(fields, withdraw.FieldAppID)
	}
	if m.FieldCleared(withdraw.FieldUserID) {
		fields = append(fields, withdraw.FieldUserID)
	}
	if m.FieldCleared(withdraw.FieldCoinTypeID) {
		fields = append(fields, withdraw.FieldCoinTypeID)
	}
	if m.FieldCleared(withdraw.FieldAccountID) {
		fields = append(fields, withdraw.FieldAccountID)
	}
	if m.FieldCleared(withdraw.FieldAddress) {
		fields = append(fields, withdraw.FieldAddress)
	}
	if m.FieldCleared(withdraw.FieldPlatformTransactionID) {
		fields = append(fields, withdraw.FieldPlatformTransactionID)
	}
	if m.FieldCleared(withdraw.FieldChainTransactionID) {
		fields = append(fields, withdraw.FieldChainTransactionID)
	}
	if m.FieldCleared(withdraw.FieldState) {
		fields = append(fields, withdraw.FieldState)
	}
	if m.FieldCleared(withdraw.FieldAmount) {
		fields = append(fields, withdraw.FieldAmount)
	}
	if m.FieldCleared(withdraw.FieldReviewID) {
		fields = append(fields, withdraw.FieldReviewID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawMutation) ClearField(name string) error {
	switch name {
	case withdraw.FieldAppID:
		m.ClearAppID()
		return nil
	case withdraw.FieldUserID:
		m.ClearUserID()
		return nil
	case withdraw.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case withdraw.FieldAccountID:
		m.ClearAccountID()
		return nil
	case withdraw.FieldAddress:
		m.ClearAddress()
		return nil
	case withdraw.FieldPlatformTransactionID:
		m.ClearPlatformTransactionID()
		return nil
	case withdraw.FieldChainTransactionID:
		m.ClearChainTransactionID()
		return nil
	case withdraw.FieldState:
		m.ClearState()
		return nil
	case withdraw.FieldAmount:
		m.ClearAmount()
		return nil
	case withdraw.FieldReviewID:
		m.ClearReviewID()
		return nil
	}
	return fmt.Errorf("unknown Withdraw nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawMutation) ResetField(name string) error {
	switch name {
	case withdraw.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdraw.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case withdraw.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case withdraw.FieldEntID:
		m.ResetEntID()
		return nil
	case withdraw.FieldAppID:
		m.ResetAppID()
		return nil
	case withdraw.FieldUserID:
		m.ResetUserID()
		return nil
	case withdraw.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case withdraw.FieldAccountID:
		m.ResetAccountID()
		return nil
	case withdraw.FieldAddress:
		m.ResetAddress()
		return nil
	case withdraw.FieldPlatformTransactionID:
		m.ResetPlatformTransactionID()
		return nil
	case withdraw.FieldChainTransactionID:
		m.ResetChainTransactionID()
		return nil
	case withdraw.FieldState:
		m.ResetState()
		return nil
	case withdraw.FieldAmount:
		m.ResetAmount()
		return nil
	case withdraw.FieldReviewID:
		m.ResetReviewID()
		return nil
	}
	return fmt.Errorf("unknown Withdraw field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Withdraw unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Withdraw edge %s", name)
}
